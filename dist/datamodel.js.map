{"version":3,"sources":["webpack://DataModel/webpack/universalModuleDefinition","webpack://DataModel/webpack/bootstrap","webpack://DataModel/./src/index.js","webpack://DataModel/./src/enums/data-format.js","webpack://DataModel/./src/enums/dimension-subtype.js","webpack://DataModel/./src/enums/measure-subtype.js","webpack://DataModel/./src/enums/field-type.js","webpack://DataModel/./src/enums/filtering-mode.js","webpack://DataModel/./src/operator/row-diffset-iterator.js","webpack://DataModel/./src/fields/field.js","webpack://DataModel/./src/utils/date-time-formatter.js","webpack://DataModel/./src/utils/column-major.js","webpack://DataModel/./src/utils/extend2.js","webpack://DataModel/./src/utils/helper.js","webpack://DataModel/./src/field-store.js","webpack://DataModel/./src/value.js","webpack://DataModel/./src/operator/bucket-creator.js","webpack://DataModel/./src/constants/index.js","webpack://DataModel/./src/operator/child-iterator.js","webpack://DataModel/./src/operator/get-common-schema.js","webpack://DataModel/./src/operator/cross-product.js","webpack://DataModel/./src/operator/merge-sort.js","webpack://DataModel/./src/operator/data-builder.js","webpack://DataModel/./src/operator/difference.js","webpack://DataModel/./src/operator/group-by-function.js","webpack://DataModel/./src/utils/reducer-store.js","webpack://DataModel/./src/operator/group-by.js","webpack://DataModel/./src/operator/natural-join-filter-function.js","webpack://DataModel/./src/operator/union.js","webpack://DataModel/./src/operator/outer-join.js","webpack://DataModel/./src/fields/partial-field.js","webpack://DataModel/./src/fields/measure.js","webpack://DataModel/./src/utils/domain-generator.js","webpack://DataModel/./src/fields/dimension.js","webpack://DataModel/./src/fields/categorical.js","webpack://DataModel/./src/fields/datetime.js","webpack://DataModel/./src/fields/discreteMeasure.js","webpack://DataModel/./src/field-creator.js","webpack://DataModel/./src/default-config.js","webpack://DataModel/./src/converter/dsv-arr.js","webpack://DataModel/./node_modules/d3-dsv/src/dsv.js","webpack://DataModel/./node_modules/d3-dsv/src/csv.js","webpack://DataModel/./node_modules/d3-dsv/src/tsv.js","webpack://DataModel/./src/converter/dsv-str.js","webpack://DataModel/./src/converter/flat-json.js","webpack://DataModel/./src/converter/auto-resolver.js","webpack://DataModel/./src/helper.js","webpack://DataModel/./src/relation.js","webpack://DataModel/./src/datamodel.js","webpack://DataModel/./src/stats/index.js","webpack://DataModel/./src/export.js","webpack://DataModel/./src/operator/compose.js","webpack://DataModel/./src/operator/pure-operators.js","webpack://DataModel/./src/operator/natural-join.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","DataModel","default","data_format","FLAT_JSON","DSV_STR","DSV_ARR","AUTO","dimension_subtype","CATEGORICAL","TEMPORAL","GEO","measure_subtype","DISCRETE","field_type","MEASURE","DIMENSION","filtering_mode","NORMAL","INVERSE","ALL","rowDiffsetIterator","rowDiffset","callback","length","split","forEach","diffStr","diffStsArr","start","end","Field","partialFeild","rowDiff","_classCallCheck","this","_ref","_rowDiff","sanitize","val","parsed","data","domain","getData","fieldType","subType","Set","Math","min","apply","max","parse","datas","clone","fieldName","type","description","getMinDiff","unit","scale","defAggFn","_this","push","bins","schema","convertToNativeDate","date","Date","pad","DateTimeFormatter","format","dtParams","undefined","nativeDate","RegExp","escape","text","replace","TOKEN_PREFIX","DATETIME_PARAM_SEQUENCE","YEAR","MONTH","DAY","HOUR","MINUTE","SECOND","MILLISECOND","defaultNumberParser","defVal","parsedVal","isFinite","parseInt","defaultRangeParser","range","nVal","toLowerCase","getTokenDefinitions","daysDef","short","long","monthsDef","H","index","extract","parser","formatter","getHours","toString","hours","P","M","getMinutes","S","getSeconds","K","getMilliseconds","a","join","day","getDay","A","e","getDate","b","month","getMonth","B","y","substring","year","getFullYear","Y","getTokenFormalNames","definitions","HOUR_12","AMPM_UPPERCASE","AMPM_LOWERCASE","SHORT_DAY","LONG_DAY","DAY_OF_MONTH","DAY_OF_MONTH_CONSTANT_WIDTH","SHORT_MONTH","LONG_MONTH","MONTH_OF_YEAR","SHORT_YEAR","LONG_YEAR","tokenResolver","defaultResolver","arg","targetParam","arguments","hourFormat24","hourFormat12","ampmLower","ampmUpper","amOrpm","isPM","findTokens","tokenPrefix","tokenLiterals","keys","occurrence","forwardChar","indexOf","token","formatAs","nDate","formattedStr","String","formattedVal","dateTimeStamp","options","extractTokenValue","dtParamSeq","noBreak","dtParamArr","args","resolverKey","resolverParams","resolverFn","param","resolvedVal","splice","tokenObj","lastOccurrenceIndex","occObj","occIndex","targetText","regexFormat","tokenArr","map","obj","occurrenceLength","extractValues","match","shift","getNativeDate","unshift","Function","column_major","store","_len","fields","Array","_key","fieldIndex","from","OBJECTSTRING","objectToStrFn","objectToStr","arrayToStr","checkCyclicRef","parentArr","bIndex","extend2","obj1","obj2","skipUndef","_typeof","merge","tgtArr","srcArr","item","srcVal","tgtVal","str","cRef","isArray","isCallable","getUniqueId","getTime","round","random","unique","arr","concat","helper_toConsumableArray","diff","uniqueVals","abs","len","isArrEqual","arr1","arr2","formatNumber","field_store","createNamespace","fieldArr","dataId","fieldsObj","retObj","field","getMeasure","getDimension","src_value","Value","value_classCallCheck","configurable","writable","_value","createBinnedFieldData","config","buckets","binCount","binSize","dataStore","binnedData","_field$domain","_field$domain2","_slicedToArray","oriMax","stops","binEnd","prevEndpoint","mid","extraBinELm","endPoint","filter","datum","add","bucket_creator_toConsumableArray","sort","DM_DERIVATIVES","SELECT","PROJECT","GROUPBY","COMPOSE","CAL_VAR","BIN","JOINS","CROSS","LEFTOUTER","RIGHTOUTER","NATURAL","FULLOUTER","LOGICAL_OPERATORS","childIterator","datamodel","operation","_children","child","_derivation","op","criteria","meta","actualProjField","groupByString","reducer","params","getCommonSchema","fs1","fs2","retArr","fs1Arr","defaultFilterFn","crossProduct","dm1","dm2","filterFn","replaceCommonSchema","jointype","applicableFilterFn","dm1FieldStore","getFieldspace","dm2FieldStore","dm1FieldStoreName","dm2FieldStoreName","commonSchemaList","Error","tmpSchema","_rowDiffset","rowAdded","rowPosition","ii","tuple","userArg","dm1Fields","prepareJoinData","dm2Fields","tupleObj","cellVal","iii","src_datamodel","defSortFn","a1","b1","mergeSort","sortFn","merge_sort_sort","lo","hi","floor","mainArr","auxArr","merge_sort_merge","getSortFn","dataType","sortType","retFunc","groupData","hashMap","Map","groupedData","fieldVal","has","set","createSortingFnArg","groupedDatum","targetFields","targetFieldDetails","label","reduce","acc","next","idx","dataBuilder","fieldStore","colIdentifier","sortingDetails","uids","addUid","assign","columnWise","reqSorting","tmpDataArr","colName","insertInd","dataObj","sortMeta","fDetails","fieldInSchema","sortingFn","slice","f","data_builder_toConsumableArray","pop","sortData","tmpData","difference_difference","hashTable","schemaNameArr","dm1FieldStoreFieldObj","dm2FieldStoreFieldObj","_colIdentifier","prepareDataHelper","dm","addData","hashData","schemaName","sum","allNulls","isNestedArray","sumVal","carry","x","group_by_function_toConsumableArray","avg","arrSum","fnList","Infinity","every","first","last","count","std","sqrt","mean","num","pow","variance","defaultReducerName","reducer_store_ReducerStore","ReducerStore","reducer_store_classCallCheck","entries","_this2","__unregister","delete","reducer_store","group_by_groupBy","dataModel","reducers","existingDataModel","sFieldArr","getPartialFieldspace","dimensions","measures","group_by_slicedToArray","_ref3","getFieldArr","reducerObj","pReducers","defaultReducer","_ref5","resolve","getReducerObj","fieldStoreObj","dbName","dimensionArr","measureArr","newDataModel","_ref7","_ref8","subtype","rowCount","hash","_","row","__calculateFieldspace","src_export","naturalJoinFilter","commonSchemaArr","retainTuple","union_union","leftOuterJoin","dataModel1","dataModel2","rightOuterJoin","partial_field","PartialField","partial_field_classCallCheck","fieldDescription","constructor","measure","Measure","measure_classCallCheck","_possibleConstructorReturn","__proto__","getPrototypeOf","fieldUnit","fieldScale","fieldDefAggFn","fieldNumberformat","numberFormat","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","domain_generator","parseFloat","isNaN","dimension","uniqueValues","trim","_unique","categorical","Categorical","categorical_classCallCheck","categorical_possibleConstructorReturn","datetime","DateTime","datetime_classCallCheck","datetime_possibleConstructorReturn","minDiff","_dtf","discreteMeasure","DiscreteMeasure","bin","discreteMeasure_classCallCheck","discreteMeasure_possibleConstructorReturn","field_creator","dataColumn","headers","headersObj","header","createUnitField","default_config","dataFormat","dsv_arr","firstRowHeader","columns","dsv_arr_toConsumableArray","EOL","EOF","QUOTE","NEWLINE","RETURN","objectConverter","JSON","stringify","src_dsv","delimiter","reFormat","DELIMITER","charCodeAt","parseRows","rows","N","I","eof","eol","j","formatRow","formatValue","test","convert","customConverter","columnSet","column","inferColumns","formatRows","csv","tsv","dsv_str","fieldSeparator","dsv","flat_json","insertionIndex","auto_resolver","converter","isString","isObject","prepareSelectionData","resp","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","done","err","return","helper_persistDerivation","model","_model$_derivation","criteriaFn","derivative","src_helper_toConsumableArray","helper_filterPropagationModel","propModels","filterByMeasure","fns","propModel","fieldsConfig","getFieldsConfig","fieldsSpace","values","v","def","some","propField","valueOf","filteredModel","select","fn","saveChild","helper_cloneWithSelect","sourceDm","selectFn","selectConfig","cloneConfig","cloned","newRowDiffSet","lastInsertedValue","li","checker","helper_selectHelper","calculateFieldsConfig","helper_cloneWithProject","projField","allFields","projectionSet","helper_updateData","relation","converterFn","converter_namespaceObject","_converterFn","_converterFn2","helper_slicedToArray","formattedData","nameSpace","_partialFieldspace","helper_propagateIdentifiers","propagateIdentifiers","nonTraversingModel","grouped","forwardPropagation","targetDM","propagationData","hasGrouped","handlePropagation","payload","sourceIdentifiers","sourceId","propagationSourceId","groupedPropModel","selectIterator","selectionModel","rejectionModel","projectIterator","projModel","project","rejectionProjModel","groupByIterator","conf","selectionGroupedModel","groupBy","rejectionGroupedModel","calculatedVariableIterator","_propModel$0$clone","_propModel$1$clone","entryModel","calculateVariable","replaceVar","exitModel","getRootDataModel","_parent","propagateToAllDataModels","identifiers","rootModels","propagationNameSpace","filteredCriteria","mutableActions","action","rootGroupByModel","groupByModel","rootModel","propConfig","src_relation","Relation","relation_classCallCheck","source","_fieldStoreName","updateData","_propagationNameSpace","immutableActions","_fieldspace","partialFieldspace","fieldStoreName","_ref2","collID","partialFieldMap","newFields","coll","fields_field","helper_updateFields","joinWith","unionWith","differenceWith","defConfig","oDm","retDataModel","getAllFields","jsonData","rowObj","fieldConfig","normalizedProjField","relation_toConsumableArray","search","_fieldConfig","fieldDef","removeChild","findIndex","sibling","parent","criteriaQueue","datamodel_classCallCheck","datamodel_possibleConstructorReturn","_onPropagation","_sortingDetails","order","withUid","dataGenerated","fieldNames","fmtFieldIdx","elem","fIdx","fmtFn","datumIdx","fieldsArr","rawData","dataInCSVArr","sortedDm","fieldinst","dependency","depVars","retrieveFn","depFieldIndices","fieldSpec","fs","suppliedFields","computedValues","fieldsData","datamodel_toConsumableArray","_createFields","datamodel_slicedToArray","addField","isMutableAction","getRootGroupByModel","find","actions","criteriaModel","propagateImmutableActions","sourceNamespace","actionName","eventName","measureName","binFieldName","dataSet","currfield","binField","stats_sum","stats_avg","stats_min","stats_max","stats_first","stats_last","stats_count","sd","Operators","compose","_len5","operations","_key5","currentDM","frstChild","derivations","compose_toConsumableArray","addParent","dispose","_len3","_key3","_len2","_key2","_len4","_key4","difference","naturalJoin","fullOuterJoin","union","Stats","stats_namespaceObject","enums_namespaceObject","DataFormat","FilteringMode","version","package_0","__webpack_exports__"],"mappings":"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","file":"datamodel.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"DataModel\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"DataModel\"] = factory();\n\telse\n\t\troot[\"DataModel\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","const DataModel = require('./export');\n\nmodule.exports = DataModel.default ? DataModel.default : DataModel;\n","/**\n * DataFormat Enum defines the format of the input data.\n * Based on the format of the data the respective adapter is loaded.\n *\n * @readonly\n * @enum {string}\n */\nconst DataFormat = {\n    FLAT_JSON: 'FlatJSON',\n    DSV_STR: 'DSVStr',\n    DSV_ARR: 'DSVArr',\n    AUTO: 'Auto'\n};\n\nexport default DataFormat;\n","/**\n * DimensionSubtype enum defines the sub types of the Dimensional Field.\n *\n * @readonly\n * @enum {string}\n */\nconst DimensionSubtype = {\n    CATEGORICAL: 'categorical',\n    TEMPORAL: 'temporal',\n    GEO: 'geo'\n};\n\nexport default DimensionSubtype;\n","/**\n * MeasureSubtype enum defines the sub types of the Dimensional Field.\n *\n * @readonly\n * @enum {string}\n */\nconst MeasureSubtype = {\n    DISCRETE: 'discrete'\n};\n\nexport default MeasureSubtype;\n","/**\n * FieldType enum defines the high level field based on which visuals are controlled.\n * Measure in a high level is numeric field and Dimension in a high level is string field.\n *\n * @readonly\n * @enum {string}\n */\nconst FieldType = {\n    MEASURE: 'measure',\n    DIMENSION: 'dimension'\n};\n\nexport default FieldType;\n","/**\n * Filtering mode enum defines the filering modes of DataModel.\n *\n * @readonly\n * @enum {string}\n */\nconst FilteringMode = {\n    NORMAL: 'normal',\n    INVERSE: 'inverse',\n    ALL: 'all'\n};\n\nexport default FilteringMode;\n","/**\n * Iterates through the diffSet array and call the callback with the current\n * index.\n *\n * @param {string} rowDiffset - The row diffset string e.g. '0-4,6,10-13'.\n * @param {Function} callback - The callback function to be called with every index.\n */\nexport function rowDiffsetIterator (rowDiffset, callback) {\n    if (rowDiffset.length > 0) {\n        const rowDiffArr = rowDiffset.split(',');\n        rowDiffArr.forEach((diffStr) => {\n            const diffStsArr = diffStr.split('-');\n            const start = +(diffStsArr[0]);\n            const end = +(diffStsArr[1] || diffStsArr[0]);\n            if (end >= start) {\n                for (let i = start; i <= end; i += 1) {\n                    callback(i);\n                }\n            }\n        });\n    }\n}\n","import { DimensionSubtype } from '../enums';\nimport { rowDiffsetIterator } from '../operator/row-diffset-iterator';\n\n/**\n * In {@link DataModel}, every tabular data consists of column, a column is stored as field.\n * Field contains all the data for a given column in an array.\n *\n * Each record consists of several fields; the fields of all records form the columns.\n * Examples of fields: name, gender, sex etc.\n *\n * In DataModel, each field can have multiple attributes which describes its data and behaviour.\n * A field can have two types of data: Measure and Dimension.\n *\n * A Dimension Field is the context on which a data is categorized and the measure is the numerical values that\n * quantify the data set.\n * In short a dimension is the lens through which you are looking at your measure data.\n *\n * Refer to {@link Schema} to get info about possible field attributes.\n *\n * @public\n * @class\n */\nexport default class Field {\n    constructor(partialFeild, rowDiff) {\n        this._ref = partialFeild;\n        this._rowDiff = rowDiff;\n    }\n\n    sanitize () {\n        return this._ref.sanitize();\n    }\n\n    parsed (val) {\n        return this._ref.parsed(val);\n    }\n\n    domain() {\n        let data = [];\n        let domain = null;\n        data = this.getData();\n        if (this._ref.fieldType === 'dimension' && this._ref.subType() !== DimensionSubtype.TEMPORAL) {\n            domain = [...new Set(data)];\n        } else {\n            let minD = Math.min.apply(null, data);\n            let maxD = Math.max.apply(null, data);\n            domain = [minD, maxD];\n        }\n\n        return domain;\n    }\n\n    parse (val) {\n        return this._ref.parse(val);\n    }\n\n\n    clone(datas) {\n        return this._ref.clone(datas);\n    }\n\n    fieldName() {\n        return this._ref.fieldName();\n    }\n\n    type() {\n        return this._ref.type();\n    }\n\n    description() {\n        return this._ref.description();\n    }\n\n    get name() {\n        return this._ref.name;\n    }\n\n    // set name(name) {\n    //     this._ref.name = name;\n    // }\n\n    get schema() {\n        return this._ref.schema;\n    }\n\n    // set schema(schema) {\n    //     this._ref.schema = schema;\n    // }\n\n    get data() {\n        return this._ref.data;\n    }\n\n    // set data(schema) {\n    //     throw new Error('Not yet implemented!');\n    // }\n\n    subType() {\n        return this._ref.subType();\n    }\n\n    getMinDiff () {\n        return this._ref.getMinDiff();\n    }\n\n    /**\n     * Getter for unit value of the field.\n     *\n     * @return {string} Returns unit of the field.\n     */\n    unit() {\n        return this._ref.unit();\n    }\n\n    /**\n     * Getter for scale value of the field.\n     *\n     * @return {string} Returns scale of the field.\n     */\n    scale() {\n        return this._ref.scale();\n    }\n\n    /**\n     * Getter for aggregation function of the field.\n     *\n     * @return {Function} Returns aggregation function of the field.\n     */\n    defAggFn() {\n        return this._ref.defAggFn();\n    }\n\n    getData() {\n        let data = [];\n        rowDiffsetIterator(this._rowDiff, (i) => {\n            data.push(this._ref.data[i]);\n        });\n        return data;\n    }\n\n    bins() {\n        return this._ref.bins();\n    }\n}\n","/**\n * Creates a JS native date object from input\n *\n * @param {string | number | Date} date Input using which date object to be created\n * @return {Date} : JS native date object\n */\nfunction convertToNativeDate (date) {\n    if (date instanceof Date) {\n        return date;\n    }\n\n    return new Date(date);\n}\n/**\n * Apply padding before a number if its less than 1o. This is used when constant digit's number to be returned\n * between 0 - 99\n *\n * @param {number} n Input to be padded\n * @return {string} Padded number\n */\nfunction pad (n) {\n    return (n < 10) ? (`0${n}`) : n;\n}\n/*\n * DateFormatter utility to convert any date format to any other date format\n * DateFormatter parse a date time stamp specified by a user abiding by rules which are defined\n * by user in terms of token. It creates JS native date object from the user specified format.\n * That native date can also be displayed\n * in any specified format.\n * This utility class only takes care of format conversion only\n */\n\n/*\n * Escapes all the special character that are used in regular expression.\n * Like\n * RegExp.escape('sgfd-$') // Output: sgfd\\-\\$\n *\n * @param text {String} : text which is to be escaped\n */\nRegExp.escape = function (text) {\n    return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n\n/**\n * DateTimeFormatter class to convert any user format of date time stamp to any other format\n * of date time stamp.\n *\n * @param {string} format Format of the date given. For the above date,\n * 'year: %Y, month: %b, day: %d'.\n * @class\n */\n/* istanbul ignore next */ function DateTimeFormatter (format) {\n    this.format = format;\n    this.dtParams = undefined;\n    this.nativeDate = undefined;\n}\n\n// The identifier of the tokens\nDateTimeFormatter.TOKEN_PREFIX = '%';\n\n// JS native Date constructor takes the date params (year, month, etc) in a certail sequence.\n// This defines the sequence of the date parameters in the constructor.\nDateTimeFormatter.DATETIME_PARAM_SEQUENCE = {\n    YEAR: 0,\n    MONTH: 1,\n    DAY: 2,\n    HOUR: 3,\n    MINUTE: 4,\n    SECOND: 5,\n    MILLISECOND: 6\n};\n\n/*\n * This is a default number parsing utility. It tries to parse a number in integer, if parsing is unsuccessful, it\n * gives back a default value.\n *\n * @param: defVal {Number} : Default no if the parsing to integer is not successful\n * @return {Function} : An closure function which is to be called by passing an the value which needs to be parsed.\n */\nDateTimeFormatter.defaultNumberParser = function (defVal) {\n    return function (val) {\n        let parsedVal;\n        if (isFinite(parsedVal = parseInt(val, 10))) {\n            return parsedVal;\n        }\n\n        return defVal;\n    };\n};\n\n/*\n * This is a default number range utility. It tries to find an element in the range. If not found it returns a\n * default no as an index.\n *\n * @param: range {Array} : The list which is to be serached\n * @param: defVal {Number} : Default no if the serach and find does not return anything\n * @return {Function} : An closure function which is to be called by passing an the value which needs to be found\n */\nDateTimeFormatter.defaultRangeParser = function (range, defVal) {\n    return (val) => {\n        let i;\n        let l;\n\n        if (!val) { return defVal; }\n\n        const nVal = val.toLowerCase();\n\n        for (i = 0, l = range.length; i < l; i++) {\n            if (range[i].toLowerCase() === nVal) {\n                return i;\n            }\n        }\n\n        if (i === undefined) {\n            return defVal;\n        }\n        return null;\n    };\n};\n\n/*\n * Defines the tokens which are supporter by the dateformatter. Using this definitation a value gets extracted from\n * the user specifed date string. This also formats the value for display purpose from native JS date.\n * The definition of each token contains the following named properties\n * {\n *     %token_name% : {\n *         name: name of the token, this is used in reverse lookup,\n *         extract: a function that returns the regular expression to extract that piece of information. All the\n *                  regex should be gouped by using ()\n *         parser: a function which receives value extracted by the above regex and parse it to get the date params\n *         formatter: a formatter function that takes milliseconds or JS Date object and format the param\n *                  represented by the token only.\n *     }\n * }\n *\n * @return {Object} : Definition of the all the supported tokens.\n */\nDateTimeFormatter.getTokenDefinitions = function () {\n    const daysDef = {\n        short: [\n            'Sun',\n            'Mon',\n            'Tue',\n            'Wed',\n            'Thu',\n            'Fri',\n            'Sat'\n        ],\n        long: [\n            'Sunday',\n            'Monday',\n            'Tuesday',\n            'Wednesday',\n            'Thursday',\n            'Friday',\n            'Saturday'\n        ]\n    };\n    const monthsDef = {\n        short: [\n            'Jan',\n            'Feb',\n            'Mar',\n            'Apr',\n            'May',\n            'Jun',\n            'Jul',\n            'Aug',\n            'Sep',\n            'Oct',\n            'Nov',\n            'Dec'\n        ],\n        long: [\n            'January',\n            'February',\n            'March',\n            'April',\n            'May',\n            'June',\n            'July',\n            'August',\n            'September',\n            'October',\n            'November',\n            'December'\n        ]\n    };\n\n    const definitions = {\n        H: {\n            // 24 hours format\n            name: 'H',\n            index: 3,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n\n                return d.getHours().toString();\n            }\n        },\n        l: {\n            // 12 hours format\n            name: 'l',\n            index: 3,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours() % 12;\n\n                return (hours === 0 ? 12 : hours).toString();\n            }\n        },\n        p: {\n            // AM or PM\n            name: 'p',\n            index: 3,\n            extract () { return '(AM|PM)'; },\n            parser: (val) => {\n                if (val) {\n                    return val.toLowerCase();\n                }\n                return null;\n            },\n            formatter: (val) => {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours();\n\n                return (hours < 12 ? 'AM' : 'PM');\n            }\n        },\n        P: {\n            // am or pm\n            name: 'P',\n            index: 3,\n            extract () { return '(am|pm)'; },\n            parser: (val) => {\n                if (val) {\n                    return val.toLowerCase();\n                }\n                return null;\n            },\n            formatter: (val) => {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours();\n\n                return (hours < 12 ? 'am' : 'pm');\n            }\n        },\n        M: {\n            // Two digit minutes 00 - 59\n            name: 'M',\n            index: 4,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const mins = d.getMinutes();\n\n                return pad(mins);\n            }\n        },\n        S: {\n            // Two digit seconds 00 - 59\n            name: 'S',\n            index: 5,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const seconds = d.getSeconds();\n\n                return pad(seconds);\n            }\n        },\n        K: {\n            // Milliseconds\n            name: 'K',\n            index: 6,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const ms = d.getMilliseconds();\n\n                return ms.toString();\n            }\n        },\n        a: {\n            // Short name of day, like Mon\n            name: 'a',\n            index: 2,\n            extract () { return `(${daysDef.short.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(daysDef.short),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDay();\n\n                return (daysDef.short[day]).toString();\n            }\n        },\n        A: {\n            // Long name of day, like Monday\n            name: 'A',\n            index: 2,\n            extract () { return `(${daysDef.long.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(daysDef.long),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDay();\n\n                return (daysDef.long[day]).toString();\n            }\n        },\n        e: {\n            // 8 of March, 11 of November\n            name: 'e',\n            index: 2,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDate();\n\n                return day.toString();\n            }\n        },\n        d: {\n            // 08 of March, 11 of November\n            name: 'd',\n            index: 2,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDate();\n\n                return pad(day);\n            }\n        },\n        b: {\n            // Short month, like Jan\n            name: 'b',\n            index: 1,\n            extract () { return `(${monthsDef.short.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(monthsDef.short),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return (monthsDef.short[month]).toString();\n            }\n        },\n        B: {\n            // Long month, like January\n            name: 'B',\n            index: 1,\n            extract () { return `(${monthsDef.long.join('|')})`; },\n            parser: DateTimeFormatter.defaultNumberParser(monthsDef.long),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return (monthsDef.long[month]).toString();\n            }\n        },\n        m: {\n            // Two digit month of year like 01 for January\n            name: 'm',\n            index: 1,\n            extract () { return '(\\\\d+)'; },\n            parser (val) { return DateTimeFormatter.defaultNumberParser()(val) - 1; },\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return pad(month + 1);\n            }\n        },\n        y: {\n            // Short year like 90 for 1990\n            name: 'y',\n            index: 0,\n            extract () { return '(\\\\d{4})'; },\n            parser (val) {\n                if (val) {\n                    const l = val.length;\n                    val = val.substring(l - 2, l);\n                }\n\n                return DateTimeFormatter.defaultNumberParser()(val);\n            },\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                let year = d.getFullYear().toString();\n                let l;\n\n                if (year) {\n                    l = year.length;\n                    year = year.substring(l - 2, l);\n                }\n\n                return year;\n            }\n        },\n        Y: {\n            // Long year like 1990\n            name: 'Y',\n            index: 0,\n            extract () { return '(\\\\d{4})'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const year = d.getFullYear().toString();\n\n                return year;\n            }\n        }\n    };\n\n    return definitions;\n};\n\n/*\n * The tokens which works internally is not user friendly in terms of memorizing the names. This gives a formal\n * definition to the informal notations.\n *\n * @return {Object} : Formal definition of the tokens\n */\nDateTimeFormatter.getTokenFormalNames = function () {\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n\n    return {\n        HOUR: definitions.H,\n        HOUR_12: definitions.l,\n        AMPM_UPPERCASE: definitions.p,\n        AMPM_LOWERCASE: definitions.P,\n        MINUTE: definitions.M,\n        SECOND: definitions.S,\n        SHORT_DAY: definitions.a,\n        LONG_DAY: definitions.A,\n        DAY_OF_MONTH: definitions.e,\n        DAY_OF_MONTH_CONSTANT_WIDTH: definitions.d,\n        SHORT_MONTH: definitions.b,\n        LONG_MONTH: definitions.B,\n        MONTH_OF_YEAR: definitions.m,\n        SHORT_YEAR: definitions.y,\n        LONG_YEAR: definitions.Y\n    };\n};\n\n/*\n * This defines the rules and declares dependencies that resolves a date parameter (year, month etc) from\n * the date time parameter array.\n *\n * @return {Object} : An object that contains dependencies and a resolver function. The dependencies values are fed\n *                  to the resolver function in that particular sequence only.\n */\nDateTimeFormatter.tokenResolver = function () {\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const defaultResolver = (...args) => { // eslint-disable-line require-jsdoc\n        let i = 0;\n        let arg;\n        let targetParam;\n        const l = args.length;\n\n        for (; i < l; i++) {\n            arg = args[i];\n            if (args[i]) {\n                targetParam = arg;\n            }\n        }\n\n        if (!targetParam) { return null; }\n\n        return targetParam[0].parser(targetParam[1]);\n    };\n\n    return {\n        YEAR: [definitions.y, definitions.Y,\n            defaultResolver\n        ],\n        MONTH: [definitions.b, definitions.B, definitions.m,\n            defaultResolver\n        ],\n        DAY: [definitions.a, definitions.A, definitions.e, definitions.d,\n            defaultResolver\n        ],\n        HOUR: [definitions.H, definitions.l, definitions.p, definitions.P,\n            function (hourFormat24, hourFormat12, ampmLower, ampmUpper) {\n                let targetParam;\n                let amOrpm;\n                let isPM;\n                let val;\n\n                if (hourFormat12 && (amOrpm = (ampmLower || ampmUpper))) {\n                    if (amOrpm[0].parser(amOrpm[1]) === 'pm') {\n                        isPM = true;\n                    }\n\n                    targetParam = hourFormat12;\n                } else if (hourFormat12) {\n                    targetParam = hourFormat12;\n                } else {\n                    targetParam = hourFormat24;\n                }\n\n                if (!targetParam) { return null; }\n\n                val = targetParam[0].parser(targetParam[1]);\n                if (isPM) {\n                    val += 12;\n                }\n                return val;\n            }\n        ],\n        MINUTE: [definitions.M,\n            defaultResolver\n        ],\n        SECOND: [definitions.S,\n            defaultResolver\n        ]\n    };\n};\n\n/*\n * Finds token from the format rule specified by a user.\n * @param format {String} : The format of the input date specified by the user\n * @return {Array} : An array of objects which contains the available token and their occurence index in the format\n */\nDateTimeFormatter.findTokens = function (format) {\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const tokenLiterals = Object.keys(definitions);\n    const occurrence = [];\n    let i;\n    let forwardChar;\n\n    while ((i = format.indexOf(tokenPrefix, i + 1)) >= 0) {\n        forwardChar = format[i + 1];\n        if (tokenLiterals.indexOf(forwardChar) === -1) { continue; }\n\n        occurrence.push({\n            index: i,\n            token: forwardChar\n        });\n    }\n\n    return occurrence;\n};\n\n/*\n * Format any JS date to a specified date given by user.\n *\n * @param date {Number | Date} : The date object which is to be formatted\n * @param format {String} : The format using which the date will be formatted for display\n */\nDateTimeFormatter.formatAs = function (date, format) {\n    const nDate = convertToNativeDate(date);\n    const occurrence = DateTimeFormatter.findTokens(format);\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    let formattedStr = String(format);\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    let token;\n    let formattedVal;\n    let i;\n    let l;\n\n    for (i = 0, l = occurrence.length; i < l; i++) {\n        token = occurrence[i].token;\n        formattedVal = definitions[token].formatter(nDate);\n        formattedStr = formattedStr.replace(new RegExp(tokenPrefix + token, 'g'), formattedVal);\n    }\n\n    return formattedStr;\n};\n\n/*\n * Parses the user specified date string to extract the date time params.\n *\n * @return {Array} : Value of date time params in an array [year, month, day, hour, minutes, seconds, milli]\n */\nDateTimeFormatter.prototype.parse = function (dateTimeStamp, options) {\n    const tokenResolver = DateTimeFormatter.tokenResolver();\n    const dtParams = this.extractTokenValue(dateTimeStamp);\n    const dtParamSeq = DateTimeFormatter.DATETIME_PARAM_SEQUENCE;\n    const noBreak = options && options.noBreak;\n    const dtParamArr = [];\n    const args = [];\n    let resolverKey;\n    let resolverParams;\n    let resolverFn;\n    let val;\n    let i;\n    let param;\n    let resolvedVal;\n    let l;\n\n    for (resolverKey in tokenResolver) {\n        if (!{}.hasOwnProperty.call(tokenResolver, resolverKey)) { continue; }\n\n        args.length = 0;\n        resolverParams = tokenResolver[resolverKey];\n        resolverFn = resolverParams.splice(resolverParams.length - 1, 1)[0];\n\n        for (i = 0, l = resolverParams.length; i < l; i++) {\n            param = resolverParams[i];\n            val = dtParams[param.name];\n\n            if (val === undefined) {\n                args.push(null);\n            } else {\n                args.push([param, val]);\n            }\n        }\n\n        resolvedVal = resolverFn.apply(this, args);\n\n        if ((resolvedVal === undefined || resolvedVal === null) && !noBreak) {\n            break;\n        }\n\n        dtParamArr[dtParamSeq[resolverKey]] = resolvedVal;\n    }\n\n    return dtParamArr;\n};\n\n/*\n * Extract the value of the token from user specified date time string.\n *\n * @return {Object} : An key value pair which contains the tokens as key and value as pair\n */\nDateTimeFormatter.prototype.extractTokenValue = function (dateTimeStamp) {\n    const format = this.format;\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    const occurrence = DateTimeFormatter.findTokens(format);\n    const tokenObj = {};\n\n    let lastOccurrenceIndex;\n    let occObj;\n    let occIndex;\n    let targetText;\n    let regexFormat;\n\n    let l;\n    let i;\n\n    regexFormat = String(format);\n\n    const tokenArr = occurrence.map(obj => obj.token);\n    const occurrenceLength = occurrence.length;\n    for (i = occurrenceLength - 1; i >= 0; i--) {\n        occIndex = occurrence[i].index;\n\n        if (occIndex + 1 === regexFormat.length - 1) {\n            lastOccurrenceIndex = occIndex;\n            continue;\n        }\n\n        if (lastOccurrenceIndex === undefined) {\n            lastOccurrenceIndex = regexFormat.length;\n        }\n\n        targetText = regexFormat.substring(occIndex + 2, lastOccurrenceIndex);\n        regexFormat = regexFormat.substring(0, occIndex + 2) +\n            RegExp.escape(targetText) +\n            regexFormat.substring(lastOccurrenceIndex, regexFormat.length);\n\n        lastOccurrenceIndex = occIndex;\n    }\n\n    for (i = 0; i < occurrenceLength; i++) {\n        occObj = occurrence[i];\n        regexFormat = regexFormat.replace(tokenPrefix + occObj.token, definitions[occObj.token].extract());\n    }\n\n    const extractValues = dateTimeStamp.match(new RegExp(regexFormat)) || [];\n    extractValues.shift();\n\n    for (i = 0, l = tokenArr.length; i < l; i++) {\n        tokenObj[tokenArr[i]] = extractValues[i];\n    }\n    return tokenObj;\n};\n\n/*\n * Give back the JS native date formed from  user specified date string\n *\n * @return {Date} : Native JS Date\n */\nDateTimeFormatter.prototype.getNativeDate = function (dateTimeStamp) {\n    if (dateTimeStamp instanceof Date) {\n        return dateTimeStamp;\n    } else if (isFinite(dateTimeStamp) && !!this.format) {\n        return new Date(dateTimeStamp);\n    }\n\n    const dtParams = this.dtParams = this.parse(dateTimeStamp);\n\n    dtParams.unshift(null);\n    this.nativeDate = new (Function.prototype.bind.apply(Date, dtParams))();\n    return this.nativeDate;\n};\n\n/*\n * Represents JS native date to a user specified format.\n *\n * @param format {String} : The format according to which the date is to be represented\n * @return {String} : The formatted date string\n */\nDateTimeFormatter.prototype.formatAs = function (format, dateTimeStamp) {\n    let nativeDate;\n\n    if (dateTimeStamp) {\n        nativeDate = this.nativeDate = this.getNativeDate(dateTimeStamp);\n    } else if (!(nativeDate = this.nativeDate)) {\n        nativeDate = this.getNativeDate(dateTimeStamp);\n    }\n\n    return DateTimeFormatter.formatAs(nativeDate, format);\n};\n\nexport { DateTimeFormatter as default };\n","/**\n * The utility function to calculate major column.\n *\n * @param {Object} store - The store object.\n * @return {Function} Returns the push function.\n */\nexport default (store) => {\n    let i = 0;\n    return (...fields) => {\n        fields.forEach((val, fieldIndex) => {\n            if (!(store[fieldIndex] instanceof Array)) {\n                store[fieldIndex] = Array.from({ length: i });\n            }\n            store[fieldIndex].push(val);\n        });\n        i++;\n    };\n};\n","/* eslint-disable */\nconst OBJECTSTRING = 'object';\nconst objectToStrFn = Object.prototype.toString;\nconst objectToStr = '[object Object]';\nconst arrayToStr = '[object Array]';\n\nfunction checkCyclicRef(obj, parentArr) {\n    let i = parentArr.length;\n    let bIndex = -1;\n\n    while (i) {\n        if (obj === parentArr[i]) {\n            bIndex = i;\n            return bIndex;\n        }\n        i -= 1;\n    }\n\n    return bIndex;\n}\n\nfunction merge(obj1, obj2, skipUndef, tgtArr, srcArr) {\n    var item,\n        srcVal,\n        tgtVal,\n        str,\n        cRef;\n    // check whether obj2 is an array\n    // if array then iterate through it's index\n    // **** MOOTOOLS precution\n\n    if (!srcArr) {\n        tgtArr = [obj1];\n        srcArr = [obj2];\n    }\n    else {\n        tgtArr.push(obj1);\n        srcArr.push(obj2);\n    }\n\n    if (obj2 instanceof Array) {\n        for (item = 0; item < obj2.length; item += 1) {\n            try {\n                srcVal = obj1[item];\n                tgtVal = obj2[item];\n            }\n            catch (e) {\n                continue;\n            }\n\n            if (typeof tgtVal !== OBJECTSTRING) {\n                if (!(skipUndef && tgtVal === undefined)) {\n                    obj1[item] = tgtVal;\n                }\n            }\n            else {\n                if (srcVal === null || typeof srcVal !== OBJECTSTRING) {\n                    srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};\n                }\n                cRef = checkCyclicRef(tgtVal, srcArr);\n                if (cRef !== -1) {\n                    srcVal = obj1[item] = tgtArr[cRef];\n                }\n                else {\n                    merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                }\n            }\n        }\n    }\n    else {\n        for (item in obj2) {\n            try {\n                srcVal = obj1[item];\n                tgtVal = obj2[item];\n            }\n            catch (e) {\n                continue;\n            }\n\n            if (tgtVal !== null && typeof tgtVal === OBJECTSTRING) {\n                // Fix for issue BUG: FWXT-602\n                // IE < 9 Object.prototype.toString.call(null) gives\n                // '[object Object]' instead of '[object Null]'\n                // that's why null value becomes Object in IE < 9\n                str = objectToStrFn.call(tgtVal);\n                if (str === objectToStr) {\n                    if (srcVal === null || typeof srcVal !== OBJECTSTRING) {\n                        srcVal = obj1[item] = {};\n                    }\n                    cRef = checkCyclicRef(tgtVal, srcArr);\n                    if (cRef !== -1) {\n                        srcVal = obj1[item] = tgtArr[cRef];\n                    }\n                    else {\n                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                    }\n                }\n                else if (str === arrayToStr) {\n                    if (srcVal === null || !(srcVal instanceof Array)) {\n                        srcVal = obj1[item] = [];\n                    }\n                    cRef = checkCyclicRef(tgtVal, srcArr);\n                    if (cRef !== -1) {\n                        srcVal = obj1[item] = tgtArr[cRef];\n                    }\n                    else {\n                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                    }\n                }\n                else {\n                    obj1[item] = tgtVal;\n                }\n            }\n            else {\n                if (skipUndef && tgtVal === undefined) {\n                    continue;\n                }\n                obj1[item] = tgtVal;\n            }\n        }\n    }\n    return obj1;\n}\n\n\nfunction extend2 (obj1, obj2, skipUndef) {\n    //if none of the arguments are object then return back\n    if (typeof obj1 !== OBJECTSTRING && typeof obj2 !== OBJECTSTRING) {\n        return null;\n    }\n\n    if (typeof obj2 !== OBJECTSTRING || obj2 === null) {\n        return obj1;\n    }\n\n    if (typeof obj1 !== OBJECTSTRING) {\n        obj1 = obj2 instanceof Array ? [] : {};\n    }\n    merge(obj1, obj2, skipUndef);\n    return obj1;\n}\n\nexport { extend2 as default };\n","/**\n * Checks whether the value is an array.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is an array otherwise returns false.\n */\nexport function isArray (val) {\n    return Array.isArray(val);\n}\n\n/**\n * Checks whether the value is an object.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is an object otherwise returns false.\n */\nexport function isObject (val) {\n    return val === Object(val);\n}\n\n/**\n * Checks whether the value is a string value.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is a string value otherwise returns false.\n */\nexport function isString (val) {\n    return typeof val === 'string';\n}\n\n/**\n * Checks whether the value is callable.\n *\n * @param {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is callable otherwise returns false.\n */\nexport function isCallable (val) {\n    return typeof val === 'function';\n}\n\n/**\n * Returns the unique values from the input array.\n *\n * @param {Array} data - The input array.\n * @return {Array} Returns a new array of unique values.\n */\nexport function uniqueValues (data) {\n    return [...new Set(data)];\n}\n\nexport const getUniqueId = () => `id-${new Date().getTime()}${Math.round(Math.random() * 10000)}`;\n\nconst unique = arr => ([...new Set(arr)]);\n\n/**\n * Gets the minimum difference between two consecutive numbers  in an array.\n * @param {Array} arr Array of numbers\n * @param {number} index index of the value\n * @return {number} minimum difference between values\n */\nexport const getMinDiff = (arr, index) => {\n    let diff;\n    let uniqueVals;\n    if (index !== undefined) {\n        uniqueVals = unique(arr.map(d => d[index]));\n    } else {\n        uniqueVals = unique(arr);\n    }\n    if (uniqueVals.length > 1) {\n        diff = Math.abs(uniqueVals[1] - uniqueVals[0]);\n        for (let i = 2, len = uniqueVals.length; i < len; i++) {\n            diff = Math.min(diff, Math.abs(uniqueVals[i] - uniqueVals[i - 1]));\n        }\n    } else {\n        diff = uniqueVals[0];\n    }\n\n    return diff;\n};\n\n/**\n * Checks Whether two arrays have same content.\n *\n * @param {Array} arr1 - The first array.\n * @param {Array} arr2 - The 2nd array.\n * @return {boolean} Returns whether two array have same content.\n */\nexport function isArrEqual(arr1, arr2) {\n    if (!isArray(arr1) || !isArray(arr2)) {\n        return arr1 === arr2;\n    }\n\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks Whether two arrays have same content.\n *\n * @param {Array} arr1 - The first array.\n * @param {Array} arr2 - The 2nd array.\n * @return {boolean} Returns whether two array have same content.\n */\nexport function formatNumber(val) {\n    return val;\n}\n","import { FieldType } from './enums';\nimport { getUniqueId } from './utils';\n\nconst fieldStore = {\n    data: {},\n\n    createNamespace (fieldArr, name) {\n        const dataId = name || getUniqueId();\n        this.data[dataId] = {\n            name: dataId,\n            fields: fieldArr,\n            fieldsObj () {\n                const retObj = {};\n                this.fields.forEach((field) => {\n                    retObj[field.name] = field;\n                });\n                return retObj;\n            },\n            getMeasure () {\n                const retObj = {};\n                this.fields.forEach((field) => {\n                    if (field.schema.type === FieldType.MEASURE) {\n                        retObj[field.name] = field;\n                    }\n                });\n                return retObj;\n            },\n            getDimension () {\n                const retObj = {};\n                this.fields.forEach((field) => {\n                    if (field.schema.type === FieldType.DIMENSION) {\n                        retObj[field.name] = field;\n                    }\n                });\n                return retObj;\n            },\n        };\n        return this.data[dataId];\n    },\n};\n\nexport default fieldStore;\n","/**\n * The wrapper class on top of the primitive value of a field.\n *\n * @todo Need to have support for StringValue, NumberValue, DateTimeValue\n * and GeoValue. These types should expose predicate API mostly.\n */\nclass Value {\n\n  /**\n   * Creates new Value instance.\n   *\n   * @param {*} val - the primitive value from the field cell.\n   * @param {string | Field} field - The field from which the value belongs.\n   */\n    constructor (val, field) {\n        Object.defineProperty(this, '_value', {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: val\n        });\n\n        this.field = field;\n    }\n\n  /**\n   * Returns the field value.\n   *\n   * @return {*} Returns the current value.\n   */\n    get value () {\n        return this._value;\n    }\n\n  /**\n   * Converts to human readable string.\n   *\n   * @override\n   * @return {string} Returns a human readable string of the field value.\n   *\n   */\n    toString () {\n        return String(this.value);\n    }\n\n  /**\n   * Returns the value of the field.\n   *\n   * @override\n   * @return {*} Returns the field value.\n   */\n    valueOf () {\n        return this.value;\n    }\n}\n\nexport default Value;\n","import { rowDiffsetIterator } from './row-diffset-iterator';\n\n/**\n * Creates bin f from the data and the supplied config.\n *\n * @param {Array} data - The input data.\n * @param {Object} config - The config object.\n * @param {number} config.binSize - The size of the bin.\n * @param {number} config.numOfBins - The number of bins to be created.\n * @return {Array} Returns an array of created bins.\n */\nexport function createBinnedFieldData (field, rowDiffset, config) {\n    let { buckets, binCount, binSize, start } = config;\n    let dataStore = [];\n    let binnedData = [];\n    let [min, max] = field.domain();\n    let oriMax = max;\n    let stops = [];\n    let binEnd;\n    let prevEndpoint;\n    let mid;\n    let range;\n\n    // create dataStore with index according to rowDiffSet\n    rowDiffsetIterator(rowDiffset, (i) => {\n        dataStore.push({\n            data: field.data[i],\n            index: i\n        });\n    });\n\n    // create buckets if buckets not given\n    if (!buckets) {\n        max += 1;\n        binSize = binSize || (max - min) / binCount;\n\n        const extraBinELm = (max - min) % binSize;\n        if (!binCount && extraBinELm !== 0) {\n            max = max + binSize - extraBinELm;\n        }\n        binEnd = min + binSize;\n        while (binEnd <= max) {\n            stops.push(binEnd);\n            binEnd += binSize;\n        }\n        start = start || min;\n        buckets = { start, stops };\n    }\n\n    // initialize intial bucket start\n    prevEndpoint = buckets.start === 0 ? 0 : buckets.start || min;\n\n    // mark each data in dataStore to respective buckets\n    buckets.stops.forEach((endPoint) => {\n        let tempStore = dataStore.filter(datum => datum.data >= prevEndpoint && datum.data < endPoint);\n        tempStore.forEach((datum) => { binnedData[datum.index] = `${prevEndpoint}-${endPoint}`; });\n        prevEndpoint = endPoint;\n    });\n\n    // create a bin for values less than start\n    dataStore.filter(datum => datum.data < buckets.start)\n                    .forEach((datum) => { binnedData[datum.index] = `${min}-${buckets.start}`; });\n\n    // create a bin for values more than end\n    dataStore.filter(datum => datum.data >= buckets.stops[buckets.stops.length - 1])\n                    .forEach((datum) =>\n                    { binnedData[datum.index] = `${buckets.stops[buckets.stops.length - 1]}-${oriMax}`; });\n\n    // create range and mid\n    // append start to bucket marks\n    buckets.stops.unshift(buckets.start);\n    range = new Set(buckets.stops);\n\n    // Add endpoints to buckets marks if not added\n    if (min < buckets.start) { range.add(min); }\n    if (oriMax > buckets.stops[buckets.stops.length - 1]) { range.add(oriMax); }\n\n    range = [...range].sort((a, b) => a - b);\n    mid = [];\n\n    for (let i = 1; i < range.length; i++) {\n        mid.push((range[i - 1] + range[i]) / 2);\n    }\n    return { data: binnedData, mid, range };\n}\n","export { DataFormat, FilteringMode } from '../enums';\n/**\n * The event name for data propagation.\n */\nexport const PROPAGATION = 'propagation';\n\n/**\n * The name of the unique row id column in DataModel.\n */\nexport const ROW_ID = '__id__';\n\n/**\n * The enums for operation names performed on DataModel.\n */\nexport const DM_DERIVATIVES = {\n    SELECT: 'select',\n    PROJECT: 'project',\n    GROUPBY: 'group',\n    COMPOSE: 'compose',\n    CAL_VAR: 'calculatedVariable',\n    BIN: 'bin'\n};\n\nexport const JOINS = {\n    CROSS: 'cross',\n    LEFTOUTER: 'leftOuter',\n    RIGHTOUTER: 'rightOuter',\n    NATURAL: 'natural',\n    FULLOUTER: 'fullOuter'\n};\n\nexport const LOGICAL_OPERATORS = {\n    AND: 'and',\n    OR: 'or'\n};\n","/* eslint-disable default-case */\nimport { DM_DERIVATIVES } from '../constants';\n\n/**\n * iterate the children and call the callback for each\n *\n * @param {DataModel} datamodel\n * @param {function} callback\n * @param {DM_DERIVATIVES} operation\n */\nfunction childIterator (datamodel, callback, operation) {\n    const children = datamodel._children;\n    children.forEach((child) => {\n        if (child._derivation\n            && child._derivation.length === 1) {\n            switch (operation) {\n            case DM_DERIVATIVES.SELECT:\n                if (child._derivation[0].op === DM_DERIVATIVES.SELECT) {\n                    callback(child, child._derivation[0].criteria);\n                }\n                break;\n            case DM_DERIVATIVES.PROJECT:\n                if (child._derivation[0].op === DM_DERIVATIVES.PROJECT) {\n                    callback(child, child._derivation[0].meta.actualProjField);\n                }\n                break;\n            case DM_DERIVATIVES.GROUPBY:\n                if (child._derivation[0].op === DM_DERIVATIVES.GROUPBY) {\n                    callback(child,\n                        { groupByString: child._derivation[0].meta.groupByString,\n                            reducer: child._derivation[0].criteria });\n                }\n                break;\n            case DM_DERIVATIVES.CAL_VAR:\n                if (child._derivation[0].op === DM_DERIVATIVES.CAL_VAR) {\n                    let params = [child._derivation[0].meta.config, [child._derivation[0].meta.fields,\n                        child._derivation[0].criteria]];\n                    callback(child, ...params);\n                }\n                break;\n            }\n        }\n    });\n}\n\n/**\n * Invokes a callback for every child created by a selection operation on a DataModel.\n *\n * @param {DataModel} datamodel - The input DataModel instance.\n * @param {Function} callback - The callback to be invoked on each child. The parameters\n * provided to the callback are the child DataModel instance and the selection\n * function used to create it.\n */\nexport function selectIterator (datamodel, callback) {\n    childIterator(datamodel, callback, DM_DERIVATIVES.SELECT);\n}\n\n/**\n * Invokes a callback for every measure child of a DataModel.\n *\n * @param {DataModel} datamodel - The input DataModel instance.\n * @param {Function} callback - The callback to be invoked on each measure child. The parameters\n * provided to the callback are the child DataModel instance and the child params.\n */\nexport function calculatedVariableIterator (datamodel, callback) {\n    childIterator(datamodel, callback, DM_DERIVATIVES.CAL_VAR);\n}\n\n/**\n * Invokes a callback for every projected child of a DataModel.\n *\n * @param {DataModel} datamodel - The input DataModel instance.\n * @param {Function} callback - The callback to be invoked on each projected child. The parameters\n * provided to the callback are the child DataModel instance and the\n * projection string.\n */\nexport function projectIterator (datamodel, callback) {\n    childIterator(datamodel, callback, DM_DERIVATIVES.PROJECT);\n}\n\n/**\n * Invokes a callback over the children created by a groupBy\n * operation on a DataModel.\n *\n * @param {DataModel} datamodel - The input DataModel instance.\n * @param {Function} callback - The callback to be invoked. The parameters\n * provided to the callback are the child DataModel instance and the groupBy string used to create it.\n */\nexport function groupByIterator (datamodel, callback) {\n    childIterator(datamodel, callback, DM_DERIVATIVES.GROUPBY);\n}\n\n","/**\n * The helper function that returns an array of common schema\n * from two fieldStore instances.\n *\n * @param {FieldStore} fs1 - The first FieldStore instance.\n * @param {FieldStore} fs2 - The second FieldStore instance.\n * @return {Array} An array containing the common schema.\n */\nexport function getCommonSchema (fs1, fs2) {\n    const retArr = [];\n    const fs1Arr = [];\n    fs1.fields.forEach((field) => {\n        fs1Arr.push(field.schema.name);\n    });\n    fs2.fields.forEach((field) => {\n        if (fs1Arr.indexOf(field.schema.name) !== -1) {\n            retArr.push(field.schema.name);\n        }\n    });\n    return retArr;\n}\n","import DataModel from '../datamodel';\nimport { extend2 } from '../utils';\nimport { getCommonSchema } from './get-common-schema';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { JOINS } from '../constants';\nimport { prepareJoinData } from '../helper';\n/**\n * Default filter function for crossProduct.\n *\n * @return {boolean} Always returns true.\n */\nfunction defaultFilterFn() { return true; }\n\n/**\n * Implementation of cross product operation between two DataModel instances.\n * It internally creates the data and schema for the new DataModel.\n *\n * @param {DataModel} dataModel1 - The left DataModel instance.\n * @param {DataModel} dataModel2 - The right DataModel instance.\n * @param {Function} filterFn - The filter function which is used to filter the tuples.\n * @param {boolean} [replaceCommonSchema=false] - The flag if the common name schema should be there.\n * @return {DataModel} Returns The newly created DataModel instance from the crossProduct operation.\n */\nexport function crossProduct (dm1, dm2, filterFn, replaceCommonSchema = false, jointype = JOINS.CROSS) {\n    const schema = [];\n    const data = [];\n    const applicableFilterFn = filterFn || defaultFilterFn;\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreName = dm1FieldStore.name;\n    const dm2FieldStoreName = dm2FieldStore.name;\n    const name = `${dm1FieldStore.name}.${dm2FieldStore.name}`;\n    const commonSchemaList = getCommonSchema(dm1FieldStore, dm2FieldStore);\n\n    if (dm1FieldStoreName === dm2FieldStoreName) {\n        throw new Error('DataModels must have different alias names');\n    }\n    // Here prepare the schema\n    dm1FieldStore.fields.forEach((field) => {\n        const tmpSchema = extend2({}, field.schema);\n        if (commonSchemaList.indexOf(tmpSchema.name) !== -1 && !replaceCommonSchema) {\n            tmpSchema.name = `${dm1FieldStore.name}.${tmpSchema.name}`;\n        }\n        schema.push(tmpSchema);\n    });\n    dm2FieldStore.fields.forEach((field) => {\n        const tmpSchema = extend2({}, field.schema);\n        if (commonSchemaList.indexOf(tmpSchema.name) !== -1) {\n            if (!replaceCommonSchema) {\n                tmpSchema.name = `${dm2FieldStore.name}.${tmpSchema.name}`;\n                schema.push(tmpSchema);\n            }\n        } else {\n            schema.push(tmpSchema);\n        }\n    });\n\n    // Here prepare Data\n    rowDiffsetIterator(dm1._rowDiffset, (i) => {\n        let rowAdded = false;\n        let rowPosition;\n        rowDiffsetIterator(dm2._rowDiffset, (ii) => {\n            const tuple = [];\n            const userArg = {};\n            userArg[dm1FieldStoreName] = {};\n            userArg[dm2FieldStoreName] = {};\n            dm1FieldStore.fields.forEach((field) => {\n                tuple.push(field.data[i]);\n                userArg[dm1FieldStoreName][field.name] = field.data[i];\n            });\n            dm2FieldStore.fields.forEach((field) => {\n                if (!(commonSchemaList.indexOf(field.schema.name) !== -1 && replaceCommonSchema)) {\n                    tuple.push(field.data[ii]);\n                }\n                userArg[dm2FieldStoreName][field.name] = field.data[ii];\n            });\n            const dm1Fields = prepareJoinData(userArg[dm1FieldStoreName]);\n            const dm2Fields = prepareJoinData(userArg[dm2FieldStoreName]);\n            if (applicableFilterFn(dm1Fields, dm2Fields)) {\n                const tupleObj = {};\n                tuple.forEach((cellVal, iii) => {\n                    tupleObj[schema[iii].name] = cellVal;\n                });\n                if (rowAdded && JOINS.CROSS !== jointype) {\n                    data[rowPosition] = tupleObj;\n                }\n                else {\n                    data.push(tupleObj);\n                    rowAdded = true;\n                    rowPosition = i;\n                }\n            }\n            else if ((jointype === JOINS.LEFTOUTER || jointype === JOINS.RIGHTOUTER) && !rowAdded) {\n                const tupleObj = {};\n                let len = dm1FieldStore.fields.length - 1;\n                tuple.forEach((cellVal, iii) => {\n                    if (iii <= len) {\n                        tupleObj[schema[iii].name] = cellVal;\n                    }\n                    else {\n                        tupleObj[schema[iii].name] = null;\n                    }\n                });\n                rowAdded = true;\n                rowPosition = i;\n                data.push(tupleObj);\n            }\n        });\n    });\n\n    return new DataModel(data, schema, { name });\n}\n","/**\n * The default sort function.\n *\n * @param {*} a - The first value.\n * @param {*} b - The second value.\n * @return {number} Returns the comparison result e.g. 1 or 0 or -1.\n */\nfunction defSortFn (a, b) {\n    const a1 = `${a}`;\n    const b1 = `${b}`;\n    if (a1 < b1) {\n        return -1;\n    }\n    if (a1 > b1) {\n        return 1;\n    }\n    return 0;\n}\n\n/**\n * The helper function for merge sort which creates the sorted array\n * from the two halves of the input array.\n *\n * @param {Array} arr - The target array which needs to be merged.\n * @param {number} lo - The starting index of the first array half.\n * @param {number} mid - The ending index of the first array half.\n * @param {number} hi - The ending index of the second array half.\n * @param {Function} sortFn - The sort function.\n */\nfunction merge (arr, lo, mid, hi, sortFn) {\n    const mainArr = arr;\n    const auxArr = [];\n    for (let i = lo; i <= hi; i += 1) {\n        auxArr[i] = mainArr[i];\n    }\n    let a = lo;\n    let b = mid + 1;\n\n    for (let i = lo; i <= hi; i += 1) {\n        if (a > mid) {\n            mainArr[i] = auxArr[b];\n            b += 1;\n        } else if (b > hi) {\n            mainArr[i] = auxArr[a];\n            a += 1;\n        } else if (sortFn(auxArr[a], auxArr[b]) <= 0) {\n            mainArr[i] = auxArr[a];\n            a += 1;\n        } else {\n            mainArr[i] = auxArr[b];\n            b += 1;\n        }\n    }\n}\n\n/**\n * The helper function for merge sort which would be called\n * recursively for sorting the array halves.\n *\n * @param {Array} arr - The target array which needs to be sorted.\n * @param {number} lo - The starting index of the array half.\n * @param {number} hi - The ending index of the array half.\n * @param {Function} sortFn - The sort function.\n * @return {Array} Returns the target array itself.\n */\nfunction sort (arr, lo, hi, sortFn) {\n    if (hi === lo) { return arr; }\n\n    const mid = lo + Math.floor((hi - lo) / 2);\n    sort(arr, lo, mid, sortFn);\n    sort(arr, mid + 1, hi, sortFn);\n    merge(arr, lo, mid, hi, sortFn);\n\n    return arr;\n}\n\n/**\n * The implementation of merge sort.\n * It is used in DataModel for stable sorting as it is not sure\n * what the sorting algorithm used by browsers is stable or not.\n *\n * @param {Array} arr - The target array which needs to be sorted.\n * @param {Function} [sortFn=defSortFn] - The sort function.\n * @return {Array} Returns the input array itself in sorted order.\n */\nexport function mergeSort (arr, sortFn = defSortFn) {\n    if (arr.length > 1) {\n        sort(arr, 0, arr.length - 1, sortFn);\n    }\n    return arr;\n}\n","import { FieldType, DimensionSubtype } from '../enums';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { mergeSort } from './merge-sort';\nimport { fieldInSchema } from '../helper';\nimport { isCallable, isArray, } from '../utils';\n/**\n * Generates the sorting functions to sort the data of a DataModel instance\n * according to the input data type.\n *\n * @param {string} dataType - The data type e.g. 'measure', 'datetime' etc.\n * @param {string} sortType - The sorting order i.e. 'asc' or 'desc'.\n * @param {integer} index - The index of the data which will be sorted.\n * @return {Function} Returns the the sorting function.\n */\nfunction getSortFn (dataType, sortType, index) {\n    let retFunc;\n    switch (dataType) {\n    case FieldType.MEASURE:\n    case DimensionSubtype.TEMPORAL:\n        if (sortType === 'desc') {\n            retFunc = (a, b) => b[index] - a[index];\n        } else {\n            retFunc = (a, b) => a[index] - b[index];\n        }\n        break;\n    default:\n        retFunc = (a, b) => {\n            const a1 = `${a[index]}`;\n            const b1 = `${b[index]}`;\n            if (a1 < b1) {\n                return sortType === 'desc' ? 1 : -1;\n            }\n            if (a1 > b1) {\n                return sortType === 'desc' ? -1 : 1;\n            }\n            return 0;\n        };\n    }\n    return retFunc;\n}\n\n/**\n * Groups the data according to the specified target field.\n *\n * @param {Array} data - The input data array.\n * @param {number} fieldIndex - The target field index within schema array.\n * @return {Array} Returns an array containing the grouped data.\n */\nfunction groupData(data, fieldIndex) {\n    const hashMap = new Map();\n    const groupedData = [];\n\n    data.forEach((datum) => {\n        const fieldVal = datum[fieldIndex];\n        if (hashMap.has(fieldVal)) {\n            groupedData[hashMap.get(fieldVal)][1].push(datum);\n        } else {\n            groupedData.push([fieldVal, [datum]]);\n            hashMap.set(fieldVal, groupedData.length - 1);\n        }\n    });\n\n    return groupedData;\n}\n\n/**\n * Creates the argument value used for sorting function when sort is done\n * with another fields.\n *\n * @param {Array} groupedDatum - The grouped datum for a single dimension field value.\n * @param {Array} targetFields - An array of the sorting fields.\n * @param {Array} targetFieldDetails - An array of the sorting field details in schema.\n * @return {Object} Returns an object containing the value of sorting fields and the target field name.\n */\nfunction createSortingFnArg(groupedDatum, targetFields, targetFieldDetails) {\n    const arg = {\n        label: groupedDatum[0]\n    };\n\n    targetFields.reduce((acc, next, idx) => {\n        acc[next] = groupedDatum[1].map(datum => datum[targetFieldDetails[idx].index]);\n        return acc;\n    }, arg);\n\n    return arg;\n}\n\n/**\n * Sorts the data before return in dataBuilder.\n *\n * @param {Object} dataObj - An object containing the data and schema.\n * @param {Array} sortingDetails - An array containing the sorting configs.\n */\nfunction sortData(dataObj, sortingDetails) {\n    const { data, schema } = dataObj;\n    let fieldName;\n    let sortMeta;\n    let fDetails;\n    let i = sortingDetails.length - 1;\n\n    for (; i >= 0; i--) {\n        fieldName = sortingDetails[i][0];\n        sortMeta = sortingDetails[i][1];\n        fDetails = fieldInSchema(schema, fieldName);\n\n        if (!fDetails) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n\n        if (isCallable(sortMeta)) {\n            // eslint-disable-next-line no-loop-func\n            mergeSort(data, (a, b) => sortMeta(a[fDetails.index], b[fDetails.index]));\n        } else if (isArray(sortMeta)) {\n            const groupedData = groupData(data, fDetails.index);\n            const sortingFn = sortMeta[sortMeta.length - 1];\n            const targetFields = sortMeta.slice(0, sortMeta.length - 1);\n            const targetFieldDetails = targetFields.map(f => fieldInSchema(schema, f));\n\n            groupedData.forEach((groupedDatum) => {\n                groupedDatum.push(createSortingFnArg(groupedDatum, targetFields, targetFieldDetails));\n            });\n\n            mergeSort(groupedData, (a, b) => {\n                const m = a[2];\n                const n = b[2];\n                return sortingFn(m, n);\n            });\n\n            // Empty the array\n            data.length = 0;\n            groupedData.forEach((datum) => {\n                data.push(...datum[1]);\n            });\n        } else {\n            sortMeta = String(sortMeta).toLowerCase() === 'desc' ? 'desc' : 'asc';\n            mergeSort(data, getSortFn(fDetails.type, sortMeta, fDetails.index));\n        }\n    }\n\n    dataObj.uids = [];\n    data.forEach((value) => {\n        dataObj.uids.push(value.pop());\n    });\n}\n\n\n/**\n * Builds the actual data array.\n *\n * @param {Array} fieldStore - An array of field.\n * @param {string} rowDiffset - A string consisting of which rows to be included eg. '0-2,4,6';\n * @param {string} colIdentifier - A string consisting of the details of which column\n * to be included eg 'date,sales,profit';\n * @param {Object} sortingDetails - An object containing the sorting details of the DataModel instance.\n * @param {Object} options - The options required to create the type of the data.\n * @return {Object} Returns an object containing the multidimensional array and the relative schema.\n */\nexport function dataBuilder (fieldStore, rowDiffset, colIdentifier, sortingDetails, options) {\n    const defOptions = {\n        addUid: false,\n        columnWise: false\n    };\n    options = Object.assign({}, defOptions, options);\n\n    const retObj = {\n        schema: [],\n        data: [],\n        uids: []\n    };\n    const addUid = options.addUid;\n    const reqSorting = sortingDetails && sortingDetails.length > 0;\n    // It stores the fields according to the colIdentifier argument\n    const tmpDataArr = [];\n    // Stores the fields according to the colIdentifier argument\n    const colIArr = colIdentifier.split(',');\n\n    colIArr.forEach((colName) => {\n        for (let i = 0; i < fieldStore.length; i += 1) {\n            if (fieldStore[i].name === colName) {\n                tmpDataArr.push(fieldStore[i]);\n                break;\n            }\n        }\n    });\n\n    // Inserts the schema to the schema object\n    tmpDataArr.forEach((field) => {\n        /** @todo Need to use extend2 here otherwise user can overwrite the schema. */\n        retObj.schema.push(field.schema);\n    });\n\n    if (addUid) {\n        retObj.schema.push({\n            name: 'uid',\n            type: 'identifier'\n        });\n    }\n\n    rowDiffsetIterator(rowDiffset, (i) => {\n        retObj.data.push([]);\n        const insertInd = retObj.data.length - 1;\n        let start = 0;\n        tmpDataArr.forEach((field, ii) => {\n            retObj.data[insertInd][ii + start] = field.data[i];\n        });\n        if (addUid) {\n            retObj.data[insertInd][tmpDataArr.length] = i;\n        }\n        // Creates an array of unique identifiers for each row\n        retObj.uids.push(i);\n\n        // If sorting needed then there is the need to expose the index\n        // mapping from the old index to its new index\n        if (reqSorting) { retObj.data[insertInd].push(i); }\n    });\n\n    // Handles the sort functionality\n    if (reqSorting) {\n        sortData(retObj, sortingDetails);\n    }\n\n    if (options.columnWise) {\n        const tmpData = Array(...Array(retObj.schema.length)).map(() => []);\n        retObj.data.forEach((tuple) => {\n            tuple.forEach((data, i) => {\n                tmpData[i].push(data);\n            });\n        });\n        retObj.data = tmpData;\n    }\n\n    return retObj;\n}\n","import DataModel from '../datamodel';\nimport { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { isArrEqual } from '../utils/helper';\n\n/**\n * Performs the union operation between two dm instances.\n *\n * @todo Fix the conflicts between union and difference terminology here.\n *\n * @param {dm} dm1 - The first dm instance.\n * @param {dm} dm2 - The second dm instance.\n * @return {dm} Returns the newly created dm after union operation.\n */\nexport function difference (dm1, dm2) {\n    const hashTable = {};\n    const schema = [];\n    const schemaNameArr = [];\n    const data = [];\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreFieldObj = dm1FieldStore.fieldsObj();\n    const dm2FieldStoreFieldObj = dm2FieldStore.fieldsObj();\n    const name = `${dm1FieldStore.name} union ${dm2FieldStore.name}`;\n\n   // For union the columns should match otherwise return a clone of the dm1\n    if (!isArrEqual(dm1._colIdentifier.split(',').sort(), dm2._colIdentifier.split(',').sort())) {\n        return null;\n    }\n\n    // Prepare the schema\n    (dm1._colIdentifier.split(',')).forEach((fieldName) => {\n        const field = dm1FieldStoreFieldObj[fieldName];\n        schema.push(extend2({}, field.schema));\n        schemaNameArr.push(field.schema.name);\n    });\n\n    /**\n     * The helper function to create the data.\n     *\n     * @param {dm} dm - The dm instance for which the data is inserted.\n     * @param {Object} fieldsObj - The fieldStore object format.\n     * @param {boolean} addData - If true only tuple will be added to the data.\n     */\n    function prepareDataHelper(dm, fieldsObj, addData) {\n        rowDiffsetIterator(dm._rowDiffset, (i) => {\n            const tuple = {};\n            let hashData = '';\n            schemaNameArr.forEach((schemaName) => {\n                const value = fieldsObj[schemaName].data[i];\n                hashData += `-${value}`;\n                tuple[schemaName] = value;\n            });\n            if (!hashTable[hashData]) {\n                if (addData) { data.push(tuple); }\n                hashTable[hashData] = true;\n            }\n        });\n    }\n\n    // Prepare the data\n    prepareDataHelper(dm2, dm2FieldStoreFieldObj, false);\n    prepareDataHelper(dm1, dm1FieldStoreFieldObj, true);\n\n    return new DataModel(data, schema, { name });\n}\n\n","/**\n * Reducer function that takes care about the sum aggregation\n * @param  {Array} arr array of values\n * @return {number}     sum of the array\n */\nfunction sum (arr) {\n    let allNulls = true;\n    const isNestedArray = arr[0] instanceof Array;\n    const sumVal = arr.reduce((carry, a) => {\n        if (isNestedArray) {\n            return carry.map((x, i) => x + a[i]);\n        }\n        allNulls = allNulls && (a === null);\n        return carry + a;\n    }, isNestedArray ? Array(...Array(arr[0].length)).map(() => 0) : 0);\n    return allNulls ? null : sumVal;\n}\n\n/**\n * reducer function that takes care about the mean aggregation\n * @param  {Array} arr array of values\n * @return {number}     mean of the array\n */\nfunction avg (arr) {\n    const isNestedArray = arr[0] instanceof Array;\n    const len = arr.length || 1;\n    const arrSum = sum(arr);\n    if (isNestedArray) {\n        return arrSum.map(x => x / len);\n    }\n    return arrSum === null ? null : arrSum / len;\n}\n\n/**\n * reducer function that gives the min value\n * @param  {Array} arr array of values\n * @return {number}     min of the array\n */\nfunction min (arr) {\n    const isNestedArray = arr[0] instanceof Array;\n    if (isNestedArray) {\n        return arr.reduce((carry, a) => carry.map((x, i) => Math.min(x, a[i])),\n        Array(...Array(arr[0].length)).map(() => Infinity));\n    }\n    return arr.every(d => d === null) ? null : Math.min(...arr);\n}\n\n/**\n * reducer function that gives the max value\n * @param  {Array} arr array of values\n * @return {number}     max of the array\n */\nfunction max (arr) {\n    const isNestedArray = arr[0] instanceof Array;\n    if (isNestedArray) {\n        return arr.reduce((carry, a) => carry.map((x, i) => Math.max(x, a[i])),\n        Array(...Array(arr[0].length)).map(() => -Infinity));\n    }\n    return arr.every(d => d === null) ? null : Math.max(...arr);\n}\n\n/**\n * reducer function that gives the first value\n * @param  {Array} arr array of values\n * @return {number}     first value of the array\n */\nfunction first (arr) {\n    return arr[0];\n}\n\n/**\n * reducer function that gives the last value\n * @param  {Array} arr array of values\n * @return {number}     last value of the array\n */\nfunction last (arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * reducer function that gives the count value\n * @param  {Array} arr array of values\n * @return {number}     count of the array\n */\nfunction count (arr) {\n    const isNestedArray = arr[0] instanceof Array;\n    const len = arr.length;\n    if (isNestedArray) {\n        return Array(...Array(arr[0].length)).map(() => len);\n    }\n    return len;\n}\n\n/**\n * Calculates the variance of the input array.\n *\n * @param {Array.<number>} arr - The input array.\n * @return {number} Returns the variance of the input array.\n */\nfunction variance (arr) {\n    let mean = avg(arr);\n    return avg(arr.map(num => (num - mean) ** 2));\n}\n\n/**\n * Calculates the square root of the variance of the input array.\n *\n * @param {Array.<number>} arr - The input array.\n * @return {number} Returns the square root of the variance.\n */\nfunction std (arr) {\n    return Math.sqrt(variance(arr));\n}\n\n\nconst fnList = {\n    sum,\n    avg,\n    min,\n    max,\n    first,\n    last,\n    count,\n    std\n};\n\nconst defaultReducerName = 'sum';\n\nexport {\n    defaultReducerName,\n    sum as defReducer,\n    fnList,\n};\n","import { defReducer, fnList } from '../operator';\n\n/**\n * A page level storage which stores, registers, unregisters reducers for all the datamodel instances. There is only one\n * reducer store available in a page. All the datamodel instances receive same instance of reducer store. DataModel\n * out of the box provides handful of {@link reducer | reducers} which can be used as reducer funciton.\n *\n * @public\n * @namespace DataModel\n */\nclass ReducerStore {\n    constructor () {\n        this.store = new Map();\n        this.store.set('defReducer', defReducer);\n\n        Object.entries(fnList).forEach((key) => {\n            this.store.set(key[0], key[1]);\n        });\n    }\n\n    /**\n     * Changes the `defaultReducer` globally. For all the fields which does not have `defAggFn` mentioned in schema, the\n     * value of `defaultReducer` is used for aggregation.\n     *\n     * @public\n     *\n     * @param {string} [reducer='sum'] name of the default reducer. It picks up the definition from store by doing name\n     *      lookup. If no name is found then it takes `sum` as the default reducer.\n     *\n     * @return {ReducerStore} instance of the singleton store in page.\n     */\n    defaultReducer (...params) {\n        if (params.length) {\n            let reducer = params[0];\n            if (typeof reducer === 'function') {\n                this.store.set('defReducer', reducer);\n            } else if (typeof reducer === 'string') {\n                if (Object.keys(fnList).indexOf(reducer) !== -1) {\n                    this.store.set('defReducer', fnList[reducer]);\n                }\n            }\n            return this;\n        }\n\n        return this.store.get('defReducer');\n    }\n\n    /**\n     *\n     * Registers a {@link reducer | reducer}.\n     * A {@link reducer | reducer} has to be registered before it is used.\n     *\n     * @example\n     *  // find the mean squared value of a given set\n     *  const reducerStore = DataModel.Reducers();\n     *\n     *  reducers.register('meanSquared', (arr) => {\n     *      const squaredVal = arr.map(item => item * item);\n     *      let sum = 0;\n     *      for (let i = 0, l = squaredVal.length; i < l; i++) {\n     *          sum += squaredVal[i++];\n     *      }\n     *\n     *      return sum;\n     *  })\n     *\n     *  // datamodel (dm) is already prepared with cars.json\n     *  const dm1 = dm.groupBy(['origin'], {\n     *      accleration: 'meanSquared'\n     *  });\n     *\n     * @public\n     *\n     * @param {string} name formal name for a reducer. If the given name already exists in store it is overridden by new\n     *      definition.\n     * @param {Function} reducer definition of {@link reducer} function.\n     *\n     * @return {Function} function for unregistering the reducer.\n     */\n    register (name, reducer) {\n        if (typeof name === 'string' && typeof reducer === 'function') {\n            this.store.set(name, reducer);\n        }\n\n        return () => { this.__unregister(name); };\n    }\n\n    __unregister (name) {\n        if (this.store.has(name)) {\n            this.store.delete(name);\n        }\n    }\n\n    resolve (name) {\n        if (name instanceof Function) {\n            return name;\n        }\n        return this.store.get(name);\n    }\n}\n\nconst reducerStore = (function () {\n    let store = null;\n\n    function getStore () {\n        if (store === null) {\n            store = new ReducerStore();\n        }\n        return store;\n    }\n    return getStore();\n}());\n\nexport default reducerStore;\n","import { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport DataModel from '../export';\nimport reducerStore from '../utils/reducer-store';\n\n/**\n * This function sanitize the user given field and return a common Array structure field\n * list\n * @param  {DataModel} dataModel the dataModel operating on\n * @param  {Array} fieldArr  user input of field Array\n * @return {Array}           arrays of field name\n */\nfunction getFieldArr (dataModel, fieldArr) {\n    const retArr = [];\n    const fieldStore = dataModel.getPartialFieldspace();\n    const dimensions = fieldStore.getDimension();\n    const measures = fieldStore.getMeasure();\n\n    Object.entries(dimensions).forEach(([key]) => {\n        if (fieldArr && fieldArr.length) {\n            if (fieldArr.indexOf(key) !== -1) {\n                retArr.push(key);\n            }\n        } else {\n            retArr.push(key);\n        }\n    });\n\n    Object.entries(measures).forEach(([key]) => {\n        if (measures[key].subType() === 'discrete') {\n            if (fieldArr && fieldArr.length) {\n                if (fieldArr.indexOf(key) !== -1) {\n                    retArr.push(key);\n                }\n            } else {\n                retArr.push(key);\n            }\n        }\n    });\n    return retArr;\n}\n\n/**\n * This sanitize the reducer provide by the user and create a common type of object.\n * user can give function Also\n * @param  {DataModel} dataModel     dataModel to worked on\n * @param  {Object|function} [reducers={}] reducer provided by the users\n * @return {Object}               object containing reducer function for every measure\n */\nfunction getReducerObj (dataModel, reducers = {}) {\n    const retObj = {};\n    const pReducers = reducers;\n    const fieldStore = dataModel.getPartialFieldspace();\n    const measures = fieldStore.getMeasure();\n    let reducer = reducerStore.defaultReducer();\n    if (typeof reducers === 'function') {\n        reducer = reducers;\n    }\n    Object.entries(measures).forEach(([key]) => {\n        if (typeof reducers[key] === 'string') {\n            pReducers[key] = reducerStore.resolve(pReducers[key]) ? reducerStore.resolve(pReducers[key]) : reducer;\n        }\n        if (typeof reducers[key] !== 'function') {\n            pReducers[key] = undefined;\n        }\n        retObj[key] = pReducers[key] || reducerStore.resolve(measures[key].defAggFn()) || reducer;\n    });\n    return retObj;\n}\n\n/**\n * main function which perform the group-by operations which reduce the measures value is the\n * fields are common according to the reducer function provided\n * @param  {DataModel} dataModel the dataModel to worked\n * @param  {Array} fieldArr  fields according to which the groupby should be worked\n * @param  {Object|Function} reducers  reducers function\n * @param {DataModel} existingDataModel Existing datamodel instance\n * @return {DataModel} new dataModel with the group by\n */\nfunction groupBy (dataModel, fieldArr, reducers, existingDataModel) {\n    const sFieldArr = getFieldArr(dataModel, fieldArr);\n    const reducerObj = getReducerObj(dataModel, reducers);\n    const fieldStore = dataModel.getPartialFieldspace();\n    const fieldStoreObj = fieldStore.fieldsObj();\n    const dbName = fieldStore.name;\n    const dimensionArr = [];\n    const measureArr = [];\n    const schema = [];\n    const hashMap = {};\n    const data = [];\n    let newDataModel;\n    // Prepare the schema\n    Object.entries(fieldStoreObj).forEach(([key, value]) => {\n        if (sFieldArr.indexOf(key) !== -1 || reducerObj[key]) {\n            schema.push(extend2({}, value.schema));\n            if (value.schema.type === 'measure' && value.schema.subtype !== 'discrete') {\n                measureArr.push(key);\n            } else if (value.schema.type === 'dimension' || value.schema.subtype === 'discrete') {\n                dimensionArr.push(key);\n            }\n        }\n    });\n    // Prepare the data\n    let rowCount = 0;\n    rowDiffsetIterator(dataModel._rowDiffset, (i) => {\n        let hash = '';\n        dimensionArr.forEach((_) => {\n            hash = `${hash}-${fieldStoreObj[_].data[i]}`;\n        });\n        if (hashMap[hash] === undefined) {\n            hashMap[hash] = rowCount;\n            data.push({});\n            dimensionArr.forEach((_) => {\n                data[rowCount][_] = fieldStoreObj[_].data[i];\n            });\n            measureArr.forEach((_) => {\n                data[rowCount][_] = [fieldStoreObj[_].data[i]];\n            });\n            rowCount += 1;\n        } else {\n            measureArr.forEach((_) => {\n                data[hashMap[hash]][_].push(fieldStoreObj[_].data[i]);\n            });\n        }\n    });\n    // reduction\n    data.forEach((row) => {\n        const tuple = row;\n        measureArr.forEach((_) => {\n            tuple[_] = reducerObj[_](row[_]);\n        });\n    });\n    if (existingDataModel) {\n        existingDataModel.__calculateFieldspace();\n        newDataModel = existingDataModel;\n    }\n    else {\n        newDataModel = new DataModel(data, schema, { name: dbName });\n    }\n    return newDataModel;\n}\n\nexport { groupBy, getFieldArr, getReducerObj };\n","import { getCommonSchema } from './get-common-schema';\n\n/**\n * The filter function used in natural join.\n * It generates a function that will have the logic to join two\n * DataModel instances by the process of natural join.\n *\n * @param {DataModel} dm1 - The left DataModel instance.\n * @param {DataModel} dm2 - The right DataModel instance.\n * @return {Function} Returns a function that is used in cross-product operation.\n */\nexport function naturalJoinFilter (dm1, dm2) {\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    // const dm1FieldStoreName = dm1FieldStore.name;\n    // const dm2FieldStoreName = dm2FieldStore.name;\n    const commonSchemaArr = getCommonSchema(dm1FieldStore, dm2FieldStore);\n\n    return (dm1Fields, dm2Fields) => {\n        let retainTuple = true;\n        commonSchemaArr.forEach((fieldName) => {\n            if (dm1Fields[fieldName].value ===\n                dm2Fields[fieldName].value && retainTuple) {\n                retainTuple = true;\n            } else {\n                retainTuple = false;\n            }\n        });\n        return retainTuple;\n    };\n}\n","import DataModel from '../export';\nimport { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { isArrEqual } from '../utils/helper';\n/**\n * Performs the union operation between two dm instances.\n *\n * @param {dm} dm1 - The first dm instance.\n * @param {dm} dm2 - The second dm instance.\n * @return {dm} Returns the newly created dm after union operation.\n */\nexport function union (dm1, dm2) {\n    const hashTable = {};\n    const schema = [];\n    const schemaNameArr = [];\n    const data = [];\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreFieldObj = dm1FieldStore.fieldsObj();\n    const dm2FieldStoreFieldObj = dm2FieldStore.fieldsObj();\n    const name = `${dm1FieldStore.name} union ${dm2FieldStore.name}`;\n\n    // For union the columns should match otherwise return a clone of the dm1\n    if (!isArrEqual(dm1._colIdentifier.split(',').sort(), dm2._colIdentifier.split(',').sort())) {\n        return null;\n    }\n\n    // Prepare the schema\n    (dm1._colIdentifier.split(',')).forEach((fieldName) => {\n        const field = dm1FieldStoreFieldObj[fieldName];\n        schema.push(extend2({}, field.schema));\n        schemaNameArr.push(field.schema.name);\n    });\n\n    /**\n     * The helper function to create the data.\n     *\n     * @param {dm} dm - The dm instance for which the data is inserted.\n     * @param {Object} fieldsObj - The fieldStore object format.\n     */\n    function prepareDataHelper (dm, fieldsObj) {\n        rowDiffsetIterator(dm._rowDiffset, (i) => {\n            const tuple = {};\n            let hashData = '';\n            schemaNameArr.forEach((schemaName) => {\n                const value = fieldsObj[schemaName].data[i];\n                hashData += `-${value}`;\n                tuple[schemaName] = value;\n            });\n            if (!hashTable[hashData]) {\n                data.push(tuple);\n                hashTable[hashData] = true;\n            }\n        });\n    }\n\n    // Prepare the data\n    prepareDataHelper(dm1, dm1FieldStoreFieldObj);\n    prepareDataHelper(dm2, dm2FieldStoreFieldObj);\n\n    return new DataModel(data, schema, { name });\n}\n","import { crossProduct } from './cross-product';\nimport { JOINS } from '../constants';\nimport { union } from './union';\n\n\nexport function leftOuterJoin (dataModel1, dataModel2, filterFn) {\n    return crossProduct(dataModel1, dataModel2, filterFn, false, JOINS.LEFTOUTER);\n}\n\nexport function rightOuterJoin (dataModel1, dataModel2, filterFn) {\n    return crossProduct(dataModel2, dataModel1, filterFn, false, JOINS.RIGHTOUTER);\n}\n\nexport function fullOuterJoin (dataModel1, dataModel2, filterFn) {\n    return union(leftOuterJoin(dataModel1, dataModel2, filterFn), rightOuterJoin(dataModel1, dataModel2, filterFn));\n}\n","import { extend2 } from '../utils';\n\n /**\n  * The base class for every field type.\n  * It provides some common functionalities.\n  */\nclass PartialField {\n\n    /**\n     * Sets basic setups to each Field instance.\n     *\n     * @param {string} name - The name or identifier of the field.\n     * @param {Array} data - The data array.\n     * @param {Object} schema - The schema of the data type.\n     */\n    constructor(name, data, schema) {\n        this.name = name;\n        this.data = data || [];\n        this.schema = schema;\n        this.fieldDescription = schema.description;\n        this.fieldType = schema.type;\n        this.sanitize();\n    }\n\n    /**\n     * Sanitizes the field data.\n     *\n     * @return {PartialField} - Returns the instance of the current context for chaining.\n     */\n    sanitize () {\n        this.data = this.data.map(d => this.parsed(this.parse(d)));\n        return this;\n    }\n\n    /**\n     * The post parsing hook for field instance.\n     *\n     * @param {*} val - The value to be parsed.\n     * @return {*} Returns the parsed value.\n     */\n    parsed (val) {\n        return val;\n    }\n\n    /**\n     * Generates and returns the domain for the field.\n     *\n     * @abstract\n     */\n    domain() {\n        throw new Error('Not yet implemented!');\n    }\n\n    subType() {\n        return null;\n    }\n\n\n    /**\n     * Parse the input value before using.\n     *\n     * @abstract\n     */\n    parse () {\n        throw new Error('Not yet implemented!');\n    }\n\n    /**\n     * Creates brand new copy of current field instance. To avoid optimization issue\n     * pass the required data otherwise current data would be copied which might\n     * be expensive.\n     *\n     * @param {Array} data - The input data, if provided current data will not be cloned.\n     * @return {PartialField} Returns the cloned field instance.\n     */\n    clone(data) {\n        data = data || extend2([], this.data);\n        const schema = extend2({}, this.schema);\n        // Here call the constructor to create an instance of\n        // the current field class type e.g. Measure, Dimension etc.\n        return new this.constructor(this.name, data, schema);\n    }\n\n    /**\n     * @return {string} Name of the field\n     */\n    fieldName() {\n        return this.name;\n    }\n\n     /**\n     * @return {string} Type of the field\n     */\n    type() {\n        return this.fieldType;\n    }\n\n    /**\n     * @return {description} Name of the field\n     */\n    description() {\n        return this.fieldDescription;\n    }\n}\n\nexport default PartialField;\n","import PartialField from './partial-field';\nimport { generateMeasureDomain, formatNumber } from '../utils';\nimport { defaultReducerName } from '../operator/group-by-function';\n\n/**\n * Represents measure field type.\n *\n * @extends PartialField\n */\nclass Measure extends PartialField {\n\n    /**\n     * Creates new Measure field instance.\n     *\n     * @param {string} name - The name of the field.\n     * @param {Array} data - An array containing the field data.\n     * @param {Object} schema - The schema for the field.\n     */\n    constructor(name, data, schema) {\n        super(name, data, schema);\n        this.fieldUnit = schema.unit;\n        this.fieldScale = schema.scale;\n        this.fieldDefAggFn = schema.defAggFn || defaultReducerName;\n        this.fieldNumberformat = schema.numberFormat instanceof Function ? schema.numberFormat : formatNumber;\n    }\n\n    /**\n     * Returns the domain for the measure field.\n     *\n     * @override\n     * @return {Array} Returns min and max values from measure values.\n     */\n    domain() {\n        return generateMeasureDomain(this.data);\n    }\n\n    /**\n     * A hook which is called for every entry(cell) of the column.\n     *\n     * @todo Fix the null data e.g. NaN value.\n     *\n     * @param {*} val - The current entry present in the column while iteration.\n     * @return {number | null} Returns the parsed number value of content of cell or null.\n     */\n    parse (val) {\n        val = parseFloat(val, 10);\n        return Number.isNaN(val) ? null : val;\n    }\n\n    /**\n     * Getter for unit value of the field.\n     *\n     * @return {string} Returns unit of the field.\n     */\n    unit() {\n        return this.fieldUnit;\n    }\n\n    /**\n     * Getter for scale value of the field.\n     *\n     * @return {string} Returns scale of the field.\n     */\n    scale() {\n        return this.fieldScale;\n    }\n\n    /**\n     * Getter for number format value of the field.\n     *\n     * @return {string} Returns number format of the field.\n     */\n    numberFormat() {\n        const formatter = this.fieldNumberformat;\n        return val => formatter(val);\n    }\n\n    /**\n     * Getter for aggregation function of the field.\n     *\n     * @return {Function} Returns aggregation function of the field.\n     */\n    defAggFn() {\n        return this.fieldDefAggFn;\n    }\n}\n\nexport default Measure;\n","/**\n * Generates domain for measure field.\n *\n * @param {Array} data - The array of data.\n * @return {Array} Returns the measure domain.\n */\nexport default (data) => {\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    data.forEach((d) => {\n        if (d < min) {\n            min = d;\n        }\n        if (d > max) {\n            max = d;\n        }\n    });\n\n    return [min, max];\n};\n","import PartialField from './partial-field';\nimport { uniqueValues } from '../utils';\n\n/**\n * Represents dimension field type.\n *\n * @extends PartialField\n */\nclass Dimension extends PartialField {\n\n    /**\n     * Returns the domain for the dimension field.\n     *\n     * @override\n     * @return {Array} Returns the unique values from dimension values.\n     */\n    domain() {\n        return uniqueValues(this.data);\n    }\n\n    /**\n     * A hook which is called for every entry(cell) of the column.\n     *\n     * @todo Fix the null data e.g. undefined or null etc.\n     *\n     * @param {*} val - The current entry present in the column while iteration.\n     * @return {string} Returns the string representation of the value.\n     */\n    parse (val) {\n        val = (val === undefined || val === null) ? '' : val.toString();\n        return val.trim();\n    }\n\n    /**\n     * Saves the cardinality of the dimensional values after parsing the data.\n     *\n     * @param {string} val - The parsed value.\n     * @return {string} Returns the input val.\n     */\n    parsed (val) {\n        this._unique = this._unique || {};\n        const unique = this._unique;\n        if (val in unique) {\n            unique[val]++;\n        } else {\n            unique[val] = 1;\n        }\n        return val;\n    }\n}\n\nexport default Dimension;\n","import { DimensionSubtype } from '../enums';\nimport Dimension from './dimension';\n\n/**\n * Represents categorical field subtype.\n *\n * @extends Dimension\n */\nclass Categorical extends Dimension {\n\n    /**\n     * Creates new Categorical field instance.\n     *\n     * @param {string} name - The name of the field.\n     * @param {Array} data - An array containing the field data.\n     * @param {Object} schema - The schema for the field.\n     */\n    constructor(name, data, schema) {\n        super(name, data, schema);\n        this.subtype = DimensionSubtype.CATEGORICAL;\n    }\n\n    /**\n     * Getter for subType value of the field.\n     *\n    * @return {string} Returns subType of the field.\n    */\n    subType() {\n        return this.subtype;\n    }\n}\n\nexport default Categorical;\n","import { DimensionSubtype } from '../enums';\nimport Dimension from './dimension';\nimport { DateTimeFormatter, getMinDiff } from '../utils';\n\n\n/**\n * Represents datetime field subtype.\n *\n * @extends Dimension\n */\nclass DateTime extends Dimension {\n\n    /**\n     * Creates new DateTime field instance.\n     *\n     * @param {string} name - The name of the field.\n     * @param {Array} data - An array containing the field data.\n     * @param {Object} schema - The schema for the field.\n     */\n    constructor(name, data, schema) {\n        super(name, data, schema);\n        this.subtype = DimensionSubtype.TEMPORAL;\n        this.minDiff = getMinDiff(this.data);\n    }\n\n    /**\n     * Getter for subType value of the field.\n     *\n    * @return {string} Returns subType of the field.\n    */\n    subType() {\n        return this.subtype;\n    }\n\n    getMinDiff () {\n        return this.minDiff;\n    }\n    /**\n    * A hook which is called for every entry(cell) of the column.\n    *\n    * @param {*} val - The current entry present in the column while iteration.\n    * @return {number} Returns the total timestamps in millisecond.\n    */\n    parse(val) {\n        if (this.schema.format) {\n            this._dtf = this._dtf || new DateTimeFormatter(this.schema.format);\n            return this._dtf.getNativeDate(val).getTime();\n        }\n\n        // If format is not present then it means the value is such that the it could be directly passed to date\n        // constructor\n        return +new Date(val);\n    }\n}\n\nexport default DateTime;\n","import Measure from './measure';\n\n/**\n * Represents categorical field subtype.\n *\n * @extends Measure\n */\nclass DiscreteMeasure extends Measure {\n    constructor(name, data, schema, bin) {\n        super(name, data, schema);\n        this.bin = bin;\n        this.subtype = 'discrete';\n    }\n\n    /**\n     * A hook which is called for every entry(cell) of the column.\n     *\n     * @todo Fix the null data e.g. undefined or null etc.\n     *\n     * @param {*} val - The current entry present in the column while iteration.\n     * @return {string} Returns the string representation of the value.\n     */\n    parse (val) {\n        val = (val === undefined || val === null) ? '' : val.toString();\n        return val.trim();\n    }\n\n    bins() {\n        return this.bin;\n    }\n    subType() {\n        return this.subtype;\n    }\n}\n\nexport default DiscreteMeasure;\n","import { FieldType, DimensionSubtype } from './enums';\nimport { Measure, Categorical, DateTime, DiscreteMeasure } from './fields';\n\n/**\n * Creates a field instance according to the provided data and schema.\n *\n * @todo Add logic for GEO dimension subtype.\n *\n * @param {Array} data - The field data array.\n * @param {Object} schema - The field schema object.\n * @return {Field} Returns the newly created field instance.\n */\nfunction createUnitField (data, schema) {\n    switch (schema.type) {\n    case FieldType.MEASURE:\n        switch (schema.subtype) {\n        case 'discrete':\n            return new DiscreteMeasure(schema.name, data, schema, schema.bins);\n        default:\n            return new Measure(schema.name, data, schema);\n        }\n    case FieldType.DIMENSION:\n    default:\n        switch (schema.subtype) {\n        case DimensionSubtype.CATEGORICAL:\n            return new Categorical(schema.name, data, schema);\n        case DimensionSubtype.TEMPORAL:\n            return new DateTime(schema.name, data, schema);\n        case DimensionSubtype.GEO:\n            return new Categorical(schema.name, data, schema);\n        default:\n            return new Categorical(schema.name, data, schema);\n        }\n    }\n}\n\n/**\n * Creates the field instances with input data and schema.\n *\n * @param {Array} dataColumn - The data array for fields.\n * @param {Array} schema - The schema array for fields.\n * @param {Array} headers - The array of header names.\n * @return {Array.<Field>} Returns an array of newly created field instances.\n */\nfunction createFields (dataColumn, schema, headers) {\n    const headersObj = {};\n\n    if (!(headers && headers.length)) {\n        headers = schema.map(item => item.name);\n    }\n\n    headers.forEach((header, i) => {\n        headersObj[header] = i;\n    });\n\n    return schema.map(item => createUnitField(dataColumn[headersObj[item.name]], item));\n}\n\nexport default createFields;\n","import { DataFormat } from './enums';\n\nexport default {\n    dataFormat: DataFormat.AUTO\n};\n","import { columnMajor } from '../utils';\n\n/**\n * Parses and converts data formatted in DSV array to a manageable internal format.\n *\n * @param {Array.<Array>} arr - A 2D array containing of the DSV data.\n * @param {Object} options - Option to control the behaviour of the parsing.\n * @param {boolean} [options.firstRowHeader=true] - Whether the first row of the dsv data is header or not.\n * @return {Array} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = [\n *    [\"a\", \"b\", \"c\"],\n *    [1, 2, 3],\n *    [4, 5, 6],\n *    [7, 8, 9]\n * ];\n */\nfunction DSVArr (arr, options) {\n    const defaultOption = {\n        firstRowHeader: true,\n    };\n    options = Object.assign({}, defaultOption, options);\n\n    let header;\n    const columns = [];\n    const push = columnMajor(columns);\n\n    if (options.firstRowHeader) {\n        // If header present then mutate the array.\n        // Do in-place mutation to save space.\n        header = arr.splice(0, 1)[0];\n    } else {\n        header = [];\n    }\n\n    arr.forEach(field => push(...field));\n\n    return [header, columns];\n}\n\nexport default DSVArr;\n","var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\"\n        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n}\n","import dsv from \"./dsv\";\n\nvar csv = dsv(\",\");\n\nexport var csvParse = csv.parse;\nexport var csvParseRows = csv.parseRows;\nexport var csvFormat = csv.format;\nexport var csvFormatRows = csv.formatRows;\n","import dsv from \"./dsv\";\n\nvar tsv = dsv(\"\\t\");\n\nexport var tsvParse = tsv.parse;\nexport var tsvParseRows = tsv.parseRows;\nexport var tsvFormat = tsv.format;\nexport var tsvFormatRows = tsv.formatRows;\n","import { dsvFormat as d3Dsv } from 'd3-dsv';\nimport DSVArr from './dsv-arr';\n\n/**\n * Parses and converts data formatted in DSV string to a manageable internal format.\n *\n * @todo Support to be given for https://tools.ietf.org/html/rfc4180.\n * @todo Sample implementation https://github.com/knrz/CSV.js/.\n *\n * @param {string} str - The input DSV string.\n * @param {Object} options - Option to control the behaviour of the parsing.\n * @param {boolean} [options.firstRowHeader=true] - Whether the first row of the dsv string data is header or not.\n * @param {string} [options.fieldSeparator=\",\"] - The separator of two consecutive field.\n * @return {Array} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = `\n * a,b,c\n * 1,2,3\n * 4,5,6\n * 7,8,9\n * `\n */\nfunction DSVStr (str, options) {\n    const defaultOption = {\n        firstRowHeader: true,\n        fieldSeparator: ','\n    };\n    options = Object.assign({}, defaultOption, options);\n\n    const dsv = d3Dsv(options.fieldSeparator);\n    return DSVArr(dsv.parseRows(str), options);\n}\n\nexport default DSVStr;\n","import { columnMajor } from '../utils';\n\n/**\n * Parses and converts data formatted in JSON to a manageable internal format.\n *\n * @param {Array.<Object>} arr - The input data formatted in JSON.\n * @return {Array.<Object>} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = [\n *    {\n *      \"a\": 1,\n *      \"b\": 2,\n *      \"c\": 3\n *    },\n *    {\n *      \"a\": 4,\n *      \"b\": 5,\n *      \"c\": 6\n *    },\n *    {\n *      \"a\": 7,\n *      \"b\": 8,\n *      \"c\": 9\n *    }\n * ];\n */\nfunction FlatJSON (arr) {\n    const header = {};\n    let i = 0;\n    let insertionIndex;\n    const columns = [];\n    const push = columnMajor(columns);\n\n    arr.forEach((item) => {\n        const fields = [];\n        for (let key in item) {\n            if (key in header) {\n                insertionIndex = header[key];\n            } else {\n                header[key] = i++;\n                insertionIndex = i - 1;\n            }\n            fields[insertionIndex] = item[key];\n        }\n        push(...fields);\n    });\n\n    return [Object.keys(header), columns];\n}\n\nexport default FlatJSON;\n","import FlatJSON from './flat-json';\nimport DSVArr from './dsv-arr';\nimport DSVStr from './dsv-str';\nimport { isArray, isObject, isString } from '../utils';\n\n/**\n * Parses the input data and detect the format automatically.\n *\n * @param {string|Array} data - The input data.\n * @param {Object} options - An optional config specific to data format.\n * @return {Array.<Object>} Returns an array of headers and column major data.\n */\nfunction Auto (data, options) {\n    let converter;\n\n    if (isString(data)) {\n        converter = DSVStr;\n    } else if (isArray(data) && isArray(data[0])) {\n        converter = DSVArr;\n    } else if (isArray(data) && (data.length === 0 || isObject(data[0]))) {\n        converter = FlatJSON;\n    } else {\n        throw new Error('Couldn\\'t detect the data format');\n    }\n\n    return converter(data, options);\n}\n\nexport default Auto;\n","import { FieldType, FilteringMode } from './enums';\nimport Field from './fields/field';\nimport fieldStore from './field-store';\nimport Value from './value';\nimport {\n    rowDiffsetIterator,\n    groupByIterator,\n    projectIterator,\n    selectIterator,\n    calculatedVariableIterator\n} from './operator';\nimport { DM_DERIVATIVES, LOGICAL_OPERATORS } from './constants';\nimport createFields from './field-creator';\nimport defaultConfig from './default-config';\nimport * as converter from './converter';\n\n/**\n * Prepares the selection data.\n */\nfunction prepareSelectionData (fields, i) {\n    const resp = {};\n    for (let field of fields) {\n        resp[field.name] = new Value(field.data[i], field);\n    }\n    return resp;\n}\n\nexport function prepareJoinData (fields) {\n    const resp = {};\n    Object.keys(fields).forEach((key) => { resp[key] = new Value(fields[key], key); });\n    return resp;\n}\n\nexport const updateFields = ([rowDiffset, colIdentifier], partialFieldspace, fieldStoreName) => {\n    let collID = colIdentifier.length ? colIdentifier.split(',') : [];\n    let partialFieldMap = partialFieldspace.fieldsObj();\n    let newFields = collID.map(coll => new Field(partialFieldMap[coll], rowDiffset));\n    return fieldStore.createNamespace(newFields, fieldStoreName);\n};\n\nexport const persistDerivation = (model, operation, config = {}, criteriaFn) => {\n    let derivative;\n    if (operation !== DM_DERIVATIVES.COMPOSE) {\n        derivative = {\n            op: operation,\n            meta: config,\n            criteria: criteriaFn\n        };\n        model._derivation.push(derivative);\n    }\n    else {\n        derivative = [...criteriaFn];\n        model._derivation.length = 0;\n        model._derivation.push(...derivative);\n    }\n};\n\nexport const selectHelper = (rowDiffset, fields, selectFn, config) => {\n    const newRowDiffSet = [];\n    let lastInsertedValue = -1;\n    let { mode } = config;\n    let li;\n    let checker = index => selectFn(prepareSelectionData(fields, index), index);\n    if (mode === FilteringMode.INVERSE) {\n        checker = index => !selectFn(prepareSelectionData(fields, index));\n    }\n    rowDiffsetIterator(rowDiffset, (i) => {\n        if (checker(i)) {\n            if (lastInsertedValue !== -1 && i === (lastInsertedValue + 1)) {\n                li = newRowDiffSet.length - 1;\n                newRowDiffSet[li] = `${newRowDiffSet[li].split('-')[0]}-${i}`;\n            } else {\n                newRowDiffSet.push(`${i}`);\n            }\n            lastInsertedValue = i;\n        }\n    });\n    return newRowDiffSet.join(',');\n};\n\nexport const filterPropagationModel = (model, propModels, config = {}) => {\n    const operation = config.operation || LOGICAL_OPERATORS.AND;\n    const filterByMeasure = config.filterByMeasure || false;\n    let fns = [];\n    if (propModels === null) {\n        fns = [() => false];\n    } else {\n        fns = propModels.map(propModel => ((dataModel) => {\n            const dataObj = dataModel.getData();\n            const schema = dataObj.schema;\n            const fieldsConfig = dataModel.getFieldsConfig();\n            const fieldsSpace = dataModel.getFieldspace().fieldsObj();\n            const data = dataObj.data;\n            const domain = Object.values(fieldsConfig).reduce((acc, v) => {\n                acc[v.def.name] = fieldsSpace[v.def.name].domain();\n                return acc;\n            }, {});\n\n            return (fields) => {\n                const include = !data.length ? false : data.some(row => schema.every((propField) => {\n                    if (!(propField.name in fields)) {\n                        return true;\n                    }\n                    const value = fields[propField.name].valueOf();\n                    if (filterByMeasure && propField.type === FieldType.MEASURE) {\n                        return value >= domain[propField.name][0] && value <= domain[propField.name][1];\n                    }\n\n                    if (propField.type !== FieldType.DIMENSION) {\n                        return true;\n                    }\n                    const idx = fieldsConfig[propField.name].index;\n                    return row[idx] === fields[propField.name].valueOf();\n                }));\n                return include;\n            };\n        })(propModel));\n    }\n\n    let filteredModel;\n    if (operation === LOGICAL_OPERATORS.AND) {\n        const clonedModel = model.clone(false, false);\n        filteredModel = clonedModel.select(fields => fns.every(fn => fn(fields)), {\n            saveChild: false,\n            mode: FilteringMode.ALL\n        });\n    } else {\n        filteredModel = model.clone(false, false).select(fields => fns.some(fn => fn(fields)), {\n            mode: FilteringMode.ALL,\n            saveChild: false\n        });\n    }\n\n    return filteredModel;\n};\n\nexport const cloneWithSelect = (sourceDm, selectFn, selectConfig, cloneConfig) => {\n    const cloned = sourceDm.clone(cloneConfig.saveChild);\n    const rowDiffset = selectHelper(\n        cloned._rowDiffset,\n        cloned.getPartialFieldspace().fields,\n        selectFn,\n        selectConfig\n    );\n    cloned._rowDiffset = rowDiffset;\n    cloned.__calculateFieldspace().calculateFieldsConfig();\n    // Store reference to child model and selector function\n    if (cloneConfig.saveChild) {\n        persistDerivation(cloned, DM_DERIVATIVES.SELECT, { config: selectConfig }, selectFn);\n    }\n\n    return cloned;\n};\n\nexport const cloneWithProject = (sourceDm, projField, config, allFields) => {\n    const cloned = sourceDm.clone(config.saveChild);\n    let projectionSet = projField;\n    if (config.mode === FilteringMode.INVERSE) {\n        projectionSet = allFields.filter(fieldName => projField.indexOf(fieldName) === -1);\n    }\n    // cloned._colIdentifier = sourceDm._colIdentifier.split(',')\n    //                         .filter(coll => projectionSet.indexOf(coll) !== -1).join();\n    cloned._colIdentifier = projectionSet.join(',');\n    cloned.__calculateFieldspace().calculateFieldsConfig();\n    // Store reference to child model and projection fields\n    if (config.saveChild) {\n        persistDerivation(\n            cloned,\n            DM_DERIVATIVES.PROJECT,\n            { projField, config, actualProjField: projectionSet },\n            null\n        );\n    }\n\n    return cloned;\n};\n\nexport const updateData = (relation, data, schema, options) => {\n    options = Object.assign(Object.assign({}, defaultConfig), options);\n    const converterFn = converter[options.dataFormat];\n\n    if (!(converterFn && typeof converterFn === 'function')) {\n        throw new Error(`No converter function found for ${options.dataFormat} format`);\n    }\n\n    const [header, formattedData] = converterFn(data, options);\n    const fieldArr = createFields(formattedData, schema, header);\n\n    // This will create a new fieldStore with the fields\n    const nameSpace = fieldStore.createNamespace(fieldArr, options.name);\n    relation._partialFieldspace = nameSpace;\n    // If data is provided create the default colIdentifier and rowDiffset\n    relation._rowDiffset = formattedData.length && formattedData[0].length ? `0-${formattedData[0].length - 1}` : '';\n    relation._colIdentifier = (schema.map(_ => _.name)).join();\n    return relation;\n};\n\nexport const fieldInSchema = (schema, field) => {\n    let i = 0;\n\n    for (; i < schema.length; ++i) {\n        if (field === schema[i].name) {\n            return {\n                type: schema[i].subtype || schema[i].type,\n                index: i\n            };\n        }\n    }\n    return null;\n};\n\nexport const propagateIdentifiers = (dataModel, propModel, config = {}, nonTraversingModel, grouped) => {\n    // function to propagate to target the DataModel instance.\n    const forwardPropagation = (targetDM, propagationData, hasGrouped) => {\n        propagateIdentifiers(targetDM, propagationData, config, nonTraversingModel, hasGrouped);\n    };\n\n    dataModel !== nonTraversingModel && dataModel.handlePropagation({\n        payload: config.payload,\n        data: propModel,\n        sourceIdentifiers: config.sourceIdentifiers,\n        sourceId: config.propagationSourceId,\n        groupedPropModel: !!grouped\n    });\n\n    // propagate to children created by SELECT operation\n    selectIterator(dataModel, (targetDM, criteria) => {\n        if (targetDM !== nonTraversingModel) {\n            const selectionModel = propModel[0].select(criteria, {\n                saveChild: false\n            });\n            const rejectionModel = propModel[1].select(criteria, {\n                saveChild: false\n            });\n\n            forwardPropagation(targetDM, [selectionModel, rejectionModel], grouped);\n        }\n    });\n    // propagate to children created by PROJECT operation\n    projectIterator(dataModel, (targetDM, projField) => {\n        if (targetDM !== nonTraversingModel) {\n            const projModel = propModel[0].project(projField, {\n                saveChild: false\n            });\n            const rejectionProjModel = propModel[1].project(projField, {\n                saveChild: false\n            });\n\n            forwardPropagation(targetDM, [projModel, rejectionProjModel], grouped);\n        }\n    });\n\n    // propagate to children created by groupBy operation\n    groupByIterator(dataModel, (targetDM, conf) => {\n        if (targetDM !== nonTraversingModel) {\n            const {\n                    reducer,\n                    groupByString\n                } = conf;\n                // group the filtered model based on groupBy string of target\n            const selectionGroupedModel = propModel[0].groupBy(groupByString.split(','), reducer, {\n                saveChild: false\n            });\n            const rejectionGroupedModel = propModel[1].groupBy(groupByString.split(','), reducer, {\n                saveChild: false\n            });\n            forwardPropagation(targetDM, [selectionGroupedModel, rejectionGroupedModel], true);\n        }\n    });\n\n    calculatedVariableIterator(dataModel, (targetDM, ...params) => {\n        if (targetDM !== nonTraversingModel) {\n            const entryModel = propModel[0].clone(false, false).calculateVariable(...params, {\n                saveChild: false,\n                replaceVar: true\n            });\n            const exitModel = propModel[1].clone(false, false).calculateVariable(...params, {\n                saveChild: false,\n                replaceVar: true\n            });\n            forwardPropagation(targetDM, [entryModel, exitModel], grouped);\n        }\n    });\n};\n\nexport const getRootGroupByModel = (model) => {\n    if (model._parent && model._derivation.find(d => d.op !== 'group')) {\n        return getRootGroupByModel(model._parent);\n    }\n    return model;\n};\n\nexport const getRootDataModel = (model) => {\n    if (model._parent) {\n        return getRootDataModel(model._parent);\n    }\n    return model;\n};\n\nexport const propagateToAllDataModels = (identifiers, rootModels, config) => {\n    let criteria;\n    let propModel;\n    const propagationNameSpace = config.propagationNameSpace;\n    const payload = config.payload;\n    const propagationSourceId = config.propagationSourceId;\n\n    if (identifiers === null) {\n        criteria = null;\n    } else {\n        const filteredCriteria = Object.entries(propagationNameSpace.mutableActions)\n            .filter(d => d[0] !== propagationSourceId)\n            .map(d => Object.values(d[1]).map(action => action.criteria));\n        criteria = [].concat(...[...filteredCriteria, identifiers]);\n    }\n\n    const rootGroupByModel = rootModels.groupByModel;\n    const rootModel = rootModels.model;\n    const propConfig = {\n        payload,\n        propagationSourceId,\n        sourceIdentifiers: identifiers\n    };\n\n    if (rootGroupByModel) {\n        propModel = filterPropagationModel(rootGroupByModel, criteria, {\n            filterByMeasure: true\n        });\n        propagateIdentifiers(rootGroupByModel, propModel, propConfig);\n    }\n\n    propModel = filterPropagationModel(rootModel, criteria, {\n        filterByMeasure: !rootGroupByModel\n    });\n    propagateIdentifiers(rootModel, propModel, propConfig, rootGroupByModel);\n};\n\nexport const propagateImmutableActions = (propagationNameSpace, rootModels, propagationSourceId) => {\n    const rootGroupByModel = rootModels.groupByModel;\n    const rootModel = rootModels.model;\n    const immutableActions = propagationNameSpace.immutableActions;\n    for (const sourceId in immutableActions) {\n        const actions = immutableActions[sourceId];\n        for (const action in actions) {\n            const criteriaModel = actions[action].criteria;\n            propagateToAllDataModels(criteriaModel, {\n                groupByModel: rootGroupByModel,\n                model: rootModel\n            }, {\n                propagationNameSpace,\n                payload: actions[action].payload,\n                propagationSourceId\n            });\n        }\n    }\n};\n","import { FilteringMode } from './enums';\nimport { getUniqueId } from './utils';\nimport { persistDerivation, updateFields, cloneWithSelect, cloneWithProject, updateData } from './helper';\nimport { crossProduct, difference, naturalJoinFilter, union } from './operator';\nimport { DM_DERIVATIVES } from './constants';\n\n/**\n * Relation provides the definitions of basic operators of relational algebra like *selection*, *projection*, *union*,\n * *difference* etc.\n *\n * It is extended by {@link DataModel} to inherit the functionalities of relational algebra concept.\n *\n * @class\n * @public\n * @module Relation\n * @namespace DataModel\n */\nclass Relation {\n\n    /**\n     * Creates a new Relation instance by providing underlying data and schema.\n     *\n     * @private\n     *\n     * @param {Object | string | Relation} data - The input tabular data in dsv or json format or\n     * an existing Relation instance object.\n     * @param {Array} schema - An array of data schema.\n     * @param {Object} [options] - The optional options.\n     */\n    constructor (...params) {\n        let source;\n\n        this._parent = null;\n        this._derivation = [];\n        this._children = [];\n\n        if (params.length === 1 && ((source = params[0]) instanceof Relation)) {\n            // parent datamodel was passed as part of source\n            this._colIdentifier = source._colIdentifier;\n            this._rowDiffset = source._rowDiffset;\n            this._parent = source;\n            this._partialFieldspace = this._parent._partialFieldspace;\n            this._fieldStoreName = getUniqueId();\n            this.__calculateFieldspace().calculateFieldsConfig();\n        } else {\n            updateData(this, ...params);\n            this._fieldStoreName = this._partialFieldspace.name;\n            this.__calculateFieldspace().calculateFieldsConfig();\n            this._propagationNameSpace = {\n                mutableActions: {},\n                immutableActions: {}\n            };\n        }\n    }\n\n    /**\n     * Retrieves the {@link Schema | schema} details for every {@link Field | field} as an array.\n     *\n     * @public\n     *\n     * @return {Array.<Schema>} Array of fields schema.\n     *      ```\n     *      [\n     *          { name: 'Name', type: 'dimension' },\n     *          { name: 'Miles_per_Gallon', type: 'measure', numberFormat: (val) => `${val} miles / gallon` },\n     *          { name: 'Cylinder', type: 'dimension' },\n     *          { name: 'Displacement', type: 'measure', defAggFn: 'max' },\n     *          { name: 'HorsePower', type: 'measure', defAggFn: 'max' },\n     *          { name: 'Weight_in_lbs', type: 'measure', defAggFn: 'avg',  },\n     *          { name: 'Acceleration', type: 'measure', defAggFn: 'avg' },\n     *          { name: 'Year', type: 'dimension', subtype: 'datetime', format: '%Y' },\n     *          { name: 'Origin' }\n     *      ]\n     *      ```\n     */\n    getSchema () {\n        return this.getFieldspace().fields.map(d => d.schema);\n    }\n\n    /**\n     * Returns the name of the {@link DataModel} instance. If no name was specified during {@link DataModel}\n     * initialization, then it returns a auto-generated name.\n     *\n     * @public\n     *\n     * @return {string} Name of the DataModel instance.\n     */\n    getName() {\n        return this._fieldStoreName;\n    }\n\n    getFieldspace () {\n        return this._fieldspace;\n    }\n\n    __calculateFieldspace () {\n        this._fieldspace = updateFields([this._rowDiffset, this._colIdentifier],\n             this.getPartialFieldspace(), this._fieldStoreName);\n        return this;\n    }\n\n    getPartialFieldspace () {\n        return this._partialFieldspace;\n    }\n\n    /**\n     * Performs {@link link_of_cross_product | cross-product} between two {@link DataModel} instances and returns a\n     * new {@link DataModel} instance containing the results. This operation is also called theta join.\n     *\n     * Cross product takes two set and create one set where each value of one set is paired with each value of another\n     * set.\n     *\n     * This method takes an optional predicate which filters the generated result rows. If the predicate returns true\n     * the combined row is included in the resulatant table.\n     *\n     * @example\n     *  let originDM = dm.project(['Origin','Origin_Formal_Name']);\n     *  let carsDM = dm.project(['Name','Miles_per_Gallon','Origin'])\n     *\n     *  console.log(carsDM.join(originDM)));\n     *\n     *  console.log(carsDM.join(originDM,\n     *      obj => obj.[originDM.getName()].Origin === obj.[carsDM.getName()].Origin));\n     *\n     * @text\n     * This is chained version of `join` operator. `join` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} joinWith - The DataModel to be joined with the current instance DataModel.\n     * @param {SelectionPredicate} filterFn - The predicate function that will filter the result of the crossProduct.\n     *\n     * @return {DataModel} New DataModel instance created after joining.\n     */\n    join (joinWith, filterFn) {\n        return crossProduct(this, joinWith, filterFn);\n    }\n\n    /**\n     * {@link natural_join | Natural join} is a special kind of cross-product join where filtering of rows are performed\n     * internally by resolving common fields are from both table and the rows with common value are included.\n     *\n     * @example\n     *  let originDM = dm.project(['Origin','Origin_Formal_Name']);\n     *  let carsDM = dm.project(['Name','Miles_per_Gallon','Origin'])\n     *\n     *  console.log(carsDM.naturalJoin(originDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} joinWith - The DataModel with which the current instance of DataModel on which the method is\n     *      called will be joined.\n     * @return {DataModel} New DataModel instance created after joining.\n     */\n    naturalJoin (joinWith) {\n        return crossProduct(this, joinWith, naturalJoinFilter(this, joinWith), true);\n    }\n\n    /**\n     * {@link link_to_union | Union} operation can be termed as vertical stacking of all rows from both the DataModel\n     * instances, provided that both of the {@link DataModel} instances should have same column names.\n     *\n     * @example\n     * console.log(EuropeanMakerDM.union(USAMakerDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} unionWith - DataModel instance for which union has to be applied with the instance on which\n     *      the method is called\n     *\n     * @return {DataModel} New DataModel instance with the result of the operation\n     */\n    union (unionWith) {\n        return union(this, unionWith);\n    }\n\n    /**\n     * {@link link_to_difference | Difference } operation only include rows which are present in the datamodel on which\n     * it was called but not on the one passed as argument.\n     *\n     * @example\n     * console.log(highPowerDM.difference(highExpensiveDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} differenceWith - DataModel instance for which difference has to be applied with the instance\n     *      on which the method is called\n     * @return {DataModel} New DataModel instance with the result of the operation\n     */\n    difference (differenceWith) {\n        return difference(this, differenceWith);\n    }\n\n    /**\n     * {@link link_to_selection | Selection} is a row filtering operation. It expects an predicate and an optional mode\n     * which control which all rows should be included in the resultant DataModel instance.\n     *\n     * {@link SelectionPredicate} is a function which returns a boolean value. For selection opearation the selection\n     * function is called for each row of DataModel instance with the current row passed as argument.\n     *\n     * After executing {@link SelectionPredicate} the rows are labeled as either an entry of selection set or an entry\n     * of rejection set.\n     *\n     * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n     * resulatant datamodel.\n     *\n     * @warning\n     * Selection and rejection set is only a logical idea for concept explanation purpose.\n     *\n     * @example\n     *  // with selection mode NORMAL:\n     *  const normDt = dt.select(fields => fields.Origin.value === \"USA\")\n     *  console.log(normDt));\n     *\n     * // with selection mode INVERSE:\n     * const inverDt = dt.select(fields => fields.Origin.value === \"USA\", { mode: DataModel.FilteringMode.INVERSE })\n     * console.log(inverDt);\n     *\n     * // with selection mode ALL:\n     * const dtArr = dt.select(fields => fields.Origin.value === \"USA\", { mode: DataModel.FilteringMode.ALL })\n     * // print the selected parts\n     * console.log(dtArr[0]);\n     * // print the inverted parts\n     * console.log(dtArr[1]);\n     *\n     * @text\n     * This is chained version of `select` operator. `select` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {SelectionPredicate} selectFn - Predicate funciton which is called for each row with the current row\n     *      ```\n     *          function (row, i)  { ... }\n     *      ```\n     * @param {Object} [config] - The configuration object to control the inclusion exclusion of a row in resultant\n     *      DataModel instance\n     * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - The mode of the selection\n     *\n     * @return {DataModel} Returns the new DataModel instance(s) after operation.\n     */\n    select (selectFn, config) {\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n        config = Object.assign({}, defConfig, config);\n\n        const cloneConfig = { saveChild: config.saveChild };\n        let oDm;\n\n        if (config.mode === FilteringMode.ALL) {\n            const selectDm = cloneWithSelect(\n                this,\n                selectFn,\n                { mode: FilteringMode.NORMAL },\n                cloneConfig\n            );\n            const rejectDm = cloneWithSelect(\n                this,\n                selectFn,\n                { mode: FilteringMode.INVERSE },\n                cloneConfig\n            );\n            oDm = [selectDm, rejectDm];\n        } else {\n            oDm = cloneWithSelect(\n                this,\n                selectFn,\n                config,\n                cloneConfig\n            );\n        }\n\n        return oDm;\n    }\n\n    /**\n     * Retrieves a boolean value if the current {@link DataModel} instance has data.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'CarName', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     * const data = [];\n     *\n     * const dt = new DataModel(schema, data);\n     * console.log(dt.isEmpty());\n     *\n     * @public\n     *\n     * @return {Boolean} True if the datamodel has no data, otherwise false.\n     */\n    isEmpty () {\n        return !this._rowDiffset.length || !this._colIdentifier.length;\n    }\n\n    /**\n     * Creates a clone from the current DataModel instance with child parent relationship.\n     *\n     * @private\n     * @param {boolean} [saveChild=true] - Whether the cloned instance would be recorded in the parent instance.\n     * @return {DataModel} - Returns the newly cloned DataModel instance.\n     */\n    clone (saveChild = true, linkParent = true) {\n        let retDataModel;\n        if (linkParent === false) {\n            const dataObj = this.getData({\n                getAllFields: true\n            });\n            const data = dataObj.data;\n            const schema = dataObj.schema;\n            const jsonData = data.map((row) => {\n                const rowObj = {};\n                schema.forEach((field, i) => {\n                    rowObj[field.name] = row[i];\n                });\n                return rowObj;\n            });\n            retDataModel = new this.constructor(jsonData, schema);\n        }\n        else {\n            retDataModel = new this.constructor(this);\n        }\n\n        if (saveChild) {\n            this._children.push(retDataModel);\n        }\n        return retDataModel;\n    }\n\n    /**\n     * {@link Projection} is filter column (field) operation. It expects list of fields' name and either include those\n     * or exclude those based on {@link FilteringMode} on the resultant variable.\n     *\n     * Projection expects array of fields name based on which it creates the selection and rejection set. All the field\n     * whose name is present in array goes in selection set and rest of the fields goes in rejection set.\n     *\n     * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n     * resulatant datamodel.\n     *\n     * @warning\n     * Selection and rejection set is only a logical idea for concept explanation purpose.\n     *\n     * @example\n     *  const dm = new DataModel(schema, data);\n     *\n     *  // with projection mode NORMAL:\n     *  const normDt = dt.project([\"Name\", \"HorsePower\"]);\n     *  console.log(normDt.getData());\n     *\n     *  // with projection mode INVERSE:\n     *  const inverDt = dt.project([\"Name\", \"HorsePower\"], { mode: DataModel.FilteringMode.INVERSE })\n     *  console.log(inverDt.getData());\n     *\n     *  // with selection mode ALL:\n     *  const dtArr = dt.project([\"Name\", \"HorsePower\"], { mode: DataModel.FilteringMode.ALL })\n     *  // print the normal parts\n     *  console.log(dtArr[0].getData());\n     *  // print the inverted parts\n     *  console.log(dtArr[1].getData());\n     *\n     * @text\n     * This is chained version of `select` operator. `select` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {Array.<string | Regexp>} projField - An array of column names in string or regular expression.\n     * @param {Object} [config] - An optional config to control the creation of new DataModel\n     * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - Mode of the projection\n     *\n     * @return {DataModel} Returns the new DataModel instance after operation.\n     */\n    project (projField, config) {\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n        config = Object.assign({}, defConfig, config);\n        const fieldConfig = this.getFieldsConfig();\n        const allFields = Object.keys(fieldConfig);\n        const { mode } = config;\n\n        let normalizedProjField = projField.reduce((acc, field) => {\n            if (field.constructor.name === 'RegExp') {\n                acc.push(...allFields.filter(fieldName => fieldName.search(field) !== -1));\n            } else if (field in fieldConfig) {\n                acc.push(field);\n            }\n            return acc;\n        }, []);\n\n        normalizedProjField = Array.from(new Set(normalizedProjField)).map(field => field.trim());\n        let dataModel;\n\n        if (mode === FilteringMode.ALL) {\n            let projectionClone = cloneWithProject(this, normalizedProjField, {\n                mode: FilteringMode.NORMAL,\n                saveChild: config.saveChild\n            }, allFields);\n            let rejectionClone = cloneWithProject(this, normalizedProjField, {\n                mode: FilteringMode.INVERSE,\n                saveChild: config.saveChild\n            }, allFields);\n            dataModel = [projectionClone, rejectionClone];\n        } else {\n            let projectionClone = cloneWithProject(this, normalizedProjField, config, allFields);\n            dataModel = projectionClone;\n        }\n\n        return dataModel;\n    }\n\n    getFieldsConfig () {\n        return this._fieldConfig;\n    }\n\n    calculateFieldsConfig () {\n        this._fieldConfig = this._fieldspace.fields.reduce((acc, fieldDef, i) => {\n            acc[fieldDef.name] = {\n                index: i,\n                def: { name: fieldDef._ref.name, type: fieldDef._ref.fieldType, subtype: fieldDef._ref.subType() }\n            };\n            return acc;\n        }, {});\n        return this;\n    }\n\n\n    /**\n     * Frees up the resources associated with the current DataModel instance and breaks all the links instance has in\n     * the DAG.\n     *\n     * @public\n     */\n    dispose () {\n        this._parent.removeChild(this);\n        this._parent = null;\n    }\n\n    /**\n     * Removes the specified child {@link DataModel} from the child list of the current {@link DataModel} instance.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'Name', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *    { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *    { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *    { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *    { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(schema, data);\n     *\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\")\n     * dt.removeChild(dt2);\n     *\n     * @private\n     *\n     * @param {DataModel} child - Delegates the parent to remove this child.\n     */\n    removeChild (child) {\n        let idx = this._children.findIndex(sibling => sibling === child);\n        idx !== -1 ? this._children.splice(idx, 1) : true;\n    }\n\n    /**\n     * Adds the specified {@link DataModel} as a parent for the current {@link DataModel} instance.\n     *\n     * The optional criteriaQueue is an array containing the history of transaction performed on parent\n     *  {@link DataModel} to get the current one.\n     *\n     * @param {DataModel} parent - The datamodel instance which will act as parent.\n     * @param {Array} criteriaQueue - Queue contains in-between operation meta-data.\n     */\n    addParent (parent, criteriaQueue = []) {\n        persistDerivation(this, DM_DERIVATIVES.COMPOSE, null, criteriaQueue);\n        this._parent = parent;\n        parent._children.push(this);\n    }\n}\n\nexport default Relation;\n","/* eslint-disable default-case */\n\nimport { FieldType } from './enums';\nimport {\n    persistDerivation,\n    getRootGroupByModel,\n    propagateToAllDataModels,\n    getRootDataModel,\n    propagateImmutableActions\n} from './helper';\nimport { DM_DERIVATIVES, PROPAGATION } from './constants';\nimport {\n    dataBuilder,\n    rowDiffsetIterator,\n    groupBy\n} from './operator';\nimport { createBinnedFieldData } from './operator/bucket-creator';\nimport Relation from './relation';\nimport reducerStore from './utils/reducer-store';\nimport createFields from './field-creator';\n\n/**\n * DataModel is an in-browser representation of tabular data. It supports\n * {@link https://en.wikipedia.org/wiki/Relational_algebra | relational algebra} operators as well as generic data\n * processing opearators.\n * DataModel extends {@link Relation} class which defines all the relational algebra opreators. DataModel gives\n * definition of generic data processing operators which are not relational algebra complient.\n *\n * @public\n * @class\n * @extends Relation\n * @memberof Datamodel\n */\nclass DataModel extends Relation {\n    /**\n     * Creates a new DataModel instance by providing data and schema. Data could be in the form of\n     * - Flat JSON\n     * - DSV String\n     * - 2D Array\n     *\n     * By default DataModel finds suitable adapter to serialize the data. DataModel also expects a\n     * {@link Schema | schema} for identifying the variables present in data.\n     *\n     * @constructor\n     * @example\n     * const data = loadData('cars.csv');\n     * const schema = [\n     *      { name: 'Name', type: 'dimension' },\n     *      { name: 'Miles_per_Gallon', type: 'measure', unit : 'cm', scale: '1000', numberformat: val => `${val}G`},\n     *      { name: 'Cylinders', type: 'dimension' },\n     *      { name: 'Displacement', type: 'measure' },\n     *      { name: 'Horsepower', type: 'measure' },\n     *      { name: 'Weight_in_lbs', type: 'measure' },\n     *      { name: 'Acceleration', type: 'measure' },\n     *      { name: 'Year', type: 'dimension', subtype: 'datetime', format: '%Y' },\n     *      { name: 'Origin', type: 'dimension' }\n     * ];\n     * const dm = new DataModel(data, schema, { name: 'Cars' });\n     * table(dm);\n     *\n     * @public\n     *\n     * @param {Array.<Object> | string | Array.<Array>} data Input data in any of the mentioned formats\n     * @param {Array.<Schema>} schema Defination of the variables. Order of the variables in data and order of the\n     *      variables in schema has to be same.\n     * @param {object} [options] Optional arguments to specify more settings regarding the creation part\n     * @param {string} [options.name] Name of the datamodel instance. If no name is given an auto generated name is\n     *      assigned to the instance.\n     * @param {string} [options.fieldSeparator=','] specify field separator type if the data is of type dsv string.\n     */\n    constructor (...args) {\n        super(...args);\n\n        this._onPropagation = [];\n        this._sortingDetails = [];\n    }\n\n    /**\n     * Reducers are simple functions which reduces an array of numbers to a representative number of the set.\n     * Like an array of numbers `[10, 20, 5, 15]` can be reduced to `12.5` if average / mean reducer function is\n     * applied. All the measure fields in datamodel (variables in data) needs a reducer to handle aggregation.\n     *\n     * @public\n     *\n     * @return {ReducerStore} Singleton instance of {@link ReducerStore}.\n     */\n    static get Reducers () {\n        return reducerStore;\n    }\n\n    /**\n     * Retrieve the data attached to an instance in JSON format.\n     *\n     * @example\n     * // DataModel instance is already prepared and assigned to dm variable\n     *  const data = dm.getData({\n     *      order: 'column',\n     *      formatter: {\n     *          origin: (val) => val === 'European Union' ? 'EU' : val;\n     *      }\n     *  });\n     *  console.log(data);\n     *\n     * @public\n     *\n     * @param {Object} [options] Options to control how the raw data is to be returned.\n     * @param {string} [options.order='row'] Defines if data is retieved in row order or column order. Possible values\n     *      are `'rows'` and `'columns'`\n     * @param {Function} [options.formatter=null] Formats the output data. This expects an object, where the keys are\n     *      the name of the variable needs to be formatted. The formatter function is called for each row passing the\n     *      value of the cell for a particular row as arguments. The formatter is a function in the form of\n     *      `function (value, rowId, schema) => { ... }`\n     *      Know more about {@link Fomatter}.\n     *\n     * @return {Array} Returns a multidimensional array of the data with schema. The return format looks like\n     *      ```\n     *          {\n     *              data,\n     *              schema\n     *          }\n     *      ```\n     */\n    getData (options) {\n        const defOptions = {\n            order: 'row',\n            formatter: null,\n            withUid: false,\n            getAllFields: false,\n            sort: []\n        };\n        options = Object.assign({}, defOptions, options);\n        const fields = this.getPartialFieldspace().fields;\n\n        const dataGenerated = dataBuilder.call(\n            this,\n            this.getPartialFieldspace().fields,\n            this._rowDiffset,\n            options.getAllFields ? fields.map(d => d.name).join() : this._colIdentifier,\n            options.sort,\n            {\n                columnWise: options.order === 'column',\n                addUid: !!options.withUid\n            }\n        );\n\n        if (!options.formatter) {\n            return dataGenerated;\n        }\n\n        const { formatter } = options;\n        const { data, schema, uids } = dataGenerated;\n        const fieldNames = schema.map((e => e.name));\n        const fmtFieldNames = Object.keys(formatter);\n        const fmtFieldIdx = fmtFieldNames.reduce((acc, next) => {\n            const idx = fieldNames.indexOf(next);\n            if (idx !== -1) {\n                acc.push([idx, formatter[next]]);\n            }\n            return acc;\n        }, []);\n\n        if (options.order === 'column') {\n            fmtFieldIdx.forEach((elem) => {\n                const fIdx = elem[0];\n                const fmtFn = elem[1];\n\n                data[fIdx].forEach((datum, datumIdx) => {\n                    data[fIdx][datumIdx] = fmtFn.call(\n                        undefined,\n                        datum,\n                        uids[datumIdx],\n                        schema[fIdx]\n                    );\n                });\n            });\n        } else {\n            data.forEach((datum, datumIdx) => {\n                fmtFieldIdx.forEach((elem) => {\n                    const fIdx = elem[0];\n                    const fmtFn = elem[1];\n\n                    datum[fIdx] = fmtFn.call(\n                        undefined,\n                        datum[fIdx],\n                        uids[datumIdx],\n                        schema[fIdx]\n                    );\n                });\n            });\n        }\n\n        return dataGenerated;\n    }\n\n    /**\n     * Groups the data using particular dimensions and by reducing measures. It expects a list of dimensions using which\n     * it projects the datamodel and perform aggregations to reduce the duplicate tuples. Refer this\n     * {@link link_to_one_example_with_group_by | document} to know the intuition behind groupBy.\n     *\n     * DataModel by default provides definition of few {@link reducer | Reducers}.\n     * {@link ReducerStore | User defined reducers} can also be registered.\n     *\n     * This is the chained implementation of `groupBy`.\n     * `groupBy` also supports {@link link_to_compose_groupBy | composability}\n     *\n     * @example\n     * const groupedDM = dm.groupBy(['Year'], { horsepower: 'max' } );\n     * console.log(groupedDm);\n     *\n     * @public\n     *\n     * @param {Array.<string>} fieldsArr - Array containing the name of dimensions\n     * @param {Object} [reducers={}] - A map whose key is the variable name and value is the name of the reducer. If its\n     *      not passed, or any variable is ommitted from the object, default aggregation function is used from the\n     *      schema of the variable.\n     *\n     * @return {DataModel} Returns a new DataModel instance after performing the groupby.\n     */\n    groupBy (fieldsArr, reducers = {}, config = { saveChild: true }) {\n        const groupByString = `${fieldsArr.join()}`;\n        let params = [this, fieldsArr, reducers];\n        const newDataModel = groupBy(...params);\n\n        if (config.saveChild) {\n            this._children.push(newDataModel);\n            persistDerivation(\n                newDataModel,\n                DM_DERIVATIVES.GROUPBY,\n                { fieldsArr, groupByString, defaultReducer: reducerStore.defaultReducer() },\n                reducers\n            );\n        }\n\n        newDataModel._parent = this;\n        return newDataModel;\n    }\n\n    /**\n     * Performs sorting operation on the current {@link DataModel} instance according to the specified sorting details.\n     * Like every other operator it doesn't mutate the current DataModel instance on which it was called, instead\n     * returns a new DataModel instance containing the sorted data.\n     *\n     * DataModel support multi level sorting by listing the variables using which sorting needs to be performed and\n     * the type of sorting `ASC` or `DESC`.\n     *\n     * In the following example, data is sorted by `Origin` field in `DESC` order in first level followed by another\n     * level of sorting by `Acceleration` in `ASC` order.\n     *\n     * @example\n     * // here dm is the pre-declared DataModel instance containing the data of 'cars.json' file\n     * let sortedDm = dm.sort([\n     *    [\"Origin\", \"DESC\"]\n     *    [\"Acceleration\"] // Default value is ASC\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * // Sort with a custom sorting function\n     * sortedDm = dm.sort([\n     *    [\"Origin\", \"DESC\"]\n     *    [\"Acceleration\", (a, b) => a - b] // Custom sorting function\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * @text\n     * DataModel also provides another sorting mechanism out of the box where sort is applied to a variable using\n     * another variable which determines the order.\n     * Like the above DataModel contains three fields `Origin`, `Name` and `Acceleration`. Now, the data in this\n     * model can be sorted by `Origin` field according to the average value of all `Acceleration` for a\n     * particular `Origin` value.\n     *\n     * @example\n     * // here dm is the pre-declared DataModel instance containing the data of 'cars.json' file\n     * const sortedDm = dm.sort([\n     *     ['Origin', ['Acceleration', (a, b) => avg(...a.Acceleration) - avg(...b.Acceleration)]]\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * @public\n     *\n     * @param {Array.<Array>} sortingDetails - Sorting details based on which the sorting will be performed.\n     * @return {DataModel} Returns a new instance of DataModel with sorted data.\n     */\n    sort (sortingDetails) {\n        const rawData = this.getData({\n            order: 'row',\n            sort: sortingDetails\n        });\n        const header = rawData.schema.map(field => field.name);\n        const dataInCSVArr = [header].concat(rawData.data);\n\n        const sortedDm = new this.constructor(dataInCSVArr, rawData.schema, { dataFormat: 'DSVArr' });\n        sortedDm._sortingDetails = sortingDetails;\n        return sortedDm;\n    }\n\n    addField (field) {\n        const fieldName = field.fieldName();\n        this._colIdentifier += `,${fieldName}`;\n        const partialFieldspace = this._partialFieldspace;\n\n        if (!partialFieldspace.fieldsObj()[field.fieldName()]) {\n            partialFieldspace.fields.push(field);\n        } else {\n            const fieldIndex = partialFieldspace.fields.findIndex(fieldinst => fieldinst.name === fieldName);\n            fieldIndex >= 0 && (partialFieldspace.fields[fieldIndex] = field);\n        }\n\n        this.__calculateFieldspace().calculateFieldsConfig();\n        return this;\n    }\n\n     /**\n     * Creates a new variable calculated from existing variable. This method expects the defination of the newly created\n     * variable and a function which resolves the value of the new variable from existing variables.\n     *\n     * Can create a new measure based on existing variables\n     * @example\n     *  // DataModel already prepared and assigned to dm vairable;\n     *  const newDm = dataModel.calculateVariable({\n     *      name: 'powerToWeight',\n     *      type: 'measure'\n     *  }, ['horsepower', 'weight_in_lbs', (hp, weight) => hp / weight ]);\n     *\n     *\n     * Can create a new dimension based on existing variables\n     * @example\n     *  // DataModel already prepared and assigned to dm vairable;\n     *  const child = dataModel.calculateVariable(\n     *     {\n     *       name: 'Efficiency',\n     *       type: 'dimension'\n     *     }, ['horsepower', (hp) => {\n     *      if (hp < 80) { return 'low'; },\n     *      else if (hp < 120) { return 'moderate'; }\n     *      else { return 'high' }\n     *  }]);\n     *\n     * @public\n     *\n     * @param {Schema} schema: Schema of newly defined variable\n     * @param {VariableResolver} resolver: Resolver format to resolve the current variable\n     *\n     * @return {DataModel} Instance of DataModel with the new field\n     */\n    calculateVariable (schema, dependency, config = { saveChild: true, replaceVar: false }) {\n        const fieldsConfig = this.getFieldsConfig();\n        const depVars = dependency.slice(0, dependency.length - 1);\n        const retrieveFn = dependency[dependency.length - 1];\n\n        if (fieldsConfig[schema.name] && !config.replaceVar) {\n            throw new Error(`${schema.name} field already exists in model.`);\n        }\n        const depFieldIndices = depVars.map((field) => {\n            const fieldSpec = fieldsConfig[field];\n            if (!fieldSpec) {\n                // @todo dont throw error here, use warning in production mode\n                throw new Error(`${field} is not a valid column name.`);\n            }\n            return fieldSpec.index;\n        });\n\n        let clone = this.clone();\n\n        const fs = clone.getFieldspace().fields;\n        const suppliedFields = depFieldIndices.map(idx => fs[idx]);\n\n        const computedValues = [];\n        rowDiffsetIterator(clone._rowDiffset, (i) => {\n            const fieldsData = suppliedFields.map(field => field.data[i]);\n            computedValues[i] = retrieveFn(...fieldsData, i, fs);\n        });\n        const [field] = createFields([computedValues], [schema], [schema.name]);\n        clone.addField(field);\n\n        if (config.saveChild) {\n            persistDerivation(clone, DM_DERIVATIVES.CAL_VAR, { config: schema, fields: depVars }, retrieveFn);\n        }\n\n        return clone;\n    }\n\n    /**\n     * Propagates changes across all the connected DataModel instances.\n     *\n     * @param {Array} identifiers - A list of identifiers that were interacted with.\n     * @param {Object} payload - The interaction specific details.\n     *\n     * @return {DataModel} DataModel instance.\n     */\n    propagate (identifiers, payload, config = {}) {\n        const isMutableAction = config.isMutableAction;\n        const propagationSourceId = config.sourceId;\n        const rootModel = getRootDataModel(this);\n        const propagationNameSpace = rootModel._propagationNameSpace;\n        const rootGroupByModel = getRootGroupByModel(this);\n        const rootModels = {\n            groupByModel: rootGroupByModel,\n            model: rootModel\n        };\n\n        propagateToAllDataModels(identifiers, rootModels, {\n            propagationNameSpace,\n            payload,\n            propagationSourceId\n        });\n\n        if (isMutableAction) {\n            propagateImmutableActions(propagationNameSpace, rootModels, propagationSourceId);\n        }\n        return this;\n    }\n\n    addToPropNamespace (sourceId, config = {}) {\n        let sourceNamespace;\n        const actionName = config.actionName;\n        const payload = config.payload;\n        const isMutableAction = config.isMutableAction;\n        const rootModel = getRootDataModel(this);\n        const propagationNameSpace = rootModel._propagationNameSpace;\n        const criteria = config.criteria;\n\n        if (isMutableAction) {\n            !propagationNameSpace.mutableActions[sourceId] && (propagationNameSpace.mutableActions[sourceId] = {});\n            sourceNamespace = propagationNameSpace.mutableActions[sourceId];\n        } else {\n            !propagationNameSpace.immutableActions[sourceId] && (propagationNameSpace.immutableActions[sourceId] = {});\n            sourceNamespace = propagationNameSpace.immutableActions[sourceId];\n        }\n\n        if (criteria === null) {\n            delete sourceNamespace[actionName];\n        } else {\n            sourceNamespace[actionName] = {\n                criteria,\n                payload\n            };\n        }\n\n        return this;\n    }\n\n    /**\n     * Associates a callback with an event name.\n     *\n     * @param {string} eventName - The name of the event.\n     * @param {Function} callback - The callback to invoke.\n     * @return {DataModel} Returns this current DataModel instance itself.\n     */\n    on (eventName, callback) {\n        switch (eventName) {\n        case PROPAGATION:\n            this._onPropagation.push(callback);\n            break;\n        }\n        return this;\n    }\n\n    /**\n     * Unsubscribes the callbacks for the provided event name.\n     *\n     * @param {string} eventName - The name of the event to unsubscribe.\n     * @return {DataModel} Returns the current DataModel instance itself.\n     */\n    unsubscribe (eventName) {\n        switch (eventName) {\n        case PROPAGATION:\n            this._onPropagation = [];\n            break;\n\n        }\n        return this;\n    }\n\n    /**\n     * This method is used to invoke the method associated with propagation.\n     *\n     * @param {Object} payload The interaction payload.\n     * @param {DataModel} identifiers The propagated DataModel.\n     * @memberof DataModel\n     */\n    handlePropagation (payload) {\n        let propListeners = this._onPropagation;\n        propListeners.forEach(fn => fn.call(this, payload));\n    }\n\n    /**\n     * Perfoms binning on a measure field based on a binning configuration. This method does not aggregate the number of\n     * rows present in DataModel instance after binning, it just adds a new field with the binned value. Refer binning\n     * {@link example_of_binning | example} to have a intuition of what binning is and the use case.\n     *\n     * Binning can be configured by\n     * - providing custom bin configuration with non uniform buckets\n     * - providing bin count\n     * - providing each bin size\n     *\n     * When custom buckets are provided as part of binning configuration\n     * @example\n     *  // DataModel already prepared and assigned to dm vairable\n     *  const buckets = {\n     *      start: 30\n     *      stops: [80, 100, 110]\n     *  };\n     *  const config = { buckets, name: 'binnedHP' }\n     *  const binDM = dataModel.bin('horsepower', config);\\\n     *\n     * @text\n     * When `binCount` is defined as part of binning configuration\n     * @example\n     *  // DataModel already prepared and assigned to dm vairable\n     *  const config = { binCount: 5, name: 'binnedHP' }\n     *  const binDM = dataModel.bin('horsepower', config);\n     *\n     * @text\n     * When `binSize` is defined as part of binning configuration\n     * @example\n     *  // DataModel already prepared and assigned to dm vairable\n     *  const config = { binSize: 200, name: 'binnedHorsepower' }\n     *  const binDM = dataModel.bin('horsepower', config);\n     *\n     * @public\n     *\n     * @param {String} name Name of measure which will be used to create bin\n     * @param {Object} config Config required for bin creation\n     * @param {Array.<Number>} config.bucketObj.stops Defination of bucket ranges. Two subsequent number from arrays\n     *      are picked and a range is created. The first number from range is inclusive and the second number from range\n     *      is exclusive.\n     * @param {Number} [config.bucketObj.startAt] Force the start of the bin from a particular number.\n     *      If not mentioned, the start of the bin or the lower domain of the data if stops is not mentioned, else its\n     *      the first value of the stop.\n     * @param {Number} config.binSize Bucket size for each bin\n     * @param {Number} config.binCount Number of bins which will be created\n     * @param {String} config.name Name of the new binned field to be created\n     *\n     * @returns {DataModel} Instance of new DataModel with the newly created bin.\n     */\n    bin (measureName, config = { }) {\n        const clone = this.clone();\n        const binFieldName = config.name || `${measureName}_binned`;\n        if (this.getFieldsConfig()[binFieldName] || !this.getFieldsConfig()[measureName]) {\n            throw new Error(`Field ${measureName} already exists.`);\n        }\n        const field = this._partialFieldspace.fields.find(currfield => currfield.name === measureName);\n        const dataSet = createBinnedFieldData(field, this._rowDiffset, config);\n        const binField = createFields([dataSet.data], [\n            {\n                name: binFieldName,\n                type: FieldType.MEASURE,\n                subtype: 'discrete', // @todo : DimensionSubtype\n                bins: {\n                    range: dataSet.range,\n                    mid: dataSet.mid\n                }\n            }], [binFieldName])[0];\n        clone.addField(binField);\n        persistDerivation(clone, DM_DERIVATIVES.BIN, { measureName, config, binFieldName }, null);\n        return clone;\n    }\n}\n\nexport default DataModel;\n","import { fnList } from '../operator/group-by-function';\n\nexport const { sum, avg, min, max, first, last, count, std: sd } = fnList;\n","import DataModel from './datamodel';\nimport {\n  compose,\n  bin,\n  select,\n  project,\n  groupby as groupBy,\n  calculateVariable,\n  sort,\n  crossProduct,\n  difference,\n  naturalJoin,\n  leftOuterJoin,\n  rightOuterJoin,\n  fullOuterJoin,\n  union\n} from './operator';\nimport * as Stats from './stats';\nimport * as enums from './enums';\nimport { DateTimeFormatter } from './utils';\nimport { DataFormat, FilteringMode } from './constants';\nimport pkg from '../package.json';\n\nDataModel.Operators = {\n    compose,\n    bin,\n    select,\n    project,\n    groupBy,\n    calculateVariable,\n    sort,\n    crossProduct,\n    difference,\n    naturalJoin,\n    leftOuterJoin,\n    rightOuterJoin,\n    fullOuterJoin,\n    union\n};\nDataModel.Stats = Stats;\nObject.assign(DataModel, enums);\nDataModel.DateTimeFormatter = DateTimeFormatter;\nDataModel.DataFormat = DataFormat;\nDataModel.FilteringMode = FilteringMode;\nDataModel.version = pkg.version;\n\nexport default DataModel;\n","\n/**\n * DataModel's opearators are exposed as composable functional operators as well as chainable operators. Chainable\n * operators are called on the instances of {@link Datamodel} and {@link Relation} class.\n *\n * Those same operators can be used as composable operators from `DataModel.Operators` namespace.\n *\n * All these operators have similar behaviour. All these operators when called with the argument returns a function\n * which expects a DataModel instance.\n *\n * @public\n * @module Operators\n * @namespace DataModel\n */\n\n/**\n * This is functional version of selection operator. {@link link_to_selection | Selection} is a row filtering operation.\n * It takes {@link SelectionPredicate | predicate} for filtering criteria and returns a function.\n * The returned function is called with the DataModel instance on which the action needs to be performed.\n *\n * {@link SelectionPredicate} is a function which returns a boolean value. For selection opearation the selection\n * function is called for each row of DataModel instance with the current row passed as argument.\n *\n * After executing {@link SelectionPredicate} the rows are labeled as either an entry of selection set or an entry\n * of rejection set.\n *\n * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n * resulatant datamodel.\n *\n * @warning\n * [Warn] Selection and rejection set is only a logical idea for concept explanation purpose.\n *\n * @error\n * [Error] `FilteringMode.ALL` is not a valid working mode for functional version of `select`. Its only avialable on the\n * chained version.\n *\n * @example\n * const select = DataModel.Operators.select;\n * usaCarsFn = select(fields => fields.Origin.value === 'USA');\n * usaCarsDm = usaCarsFn(dm);\n * console.log(usaCarsDm);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {SelectionPredicate} selectFn - Predicate funciton which is called for each row with the current row\n *      ```\n *          function (row, i)  { ... }\n *      ```\n * @param {Object} [config] - The configuration object to control the inclusion exclusion of a row in resultant\n *      DataModel instance\n * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - The mode of the selection\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const select = (...args) => dm => dm.select(...args);\n\n/**\n * This is functional version of projection operator. {@link link_to_projection | Projection} is a column filtering\n * operation.It expects list of fields name and either include those or exclude those based on {@link FilteringMode} on\n * the  resultant variable.It returns a function which is called with the DataModel instance on which the action needs\n * to be performed.\n *\n * Projection expects array of fields name based on which it creates the selection and rejection set. All the field\n * whose name is present in array goes in selection set and rest of the fields goes in rejection set.\n *\n * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n * resulatant datamodel.\n *\n * @warning\n * Selection and rejection set is only a logical idea for concept explanation purpose.\n *\n * @error\n * `FilteringMode.ALL` is not a valid working mode for functional version of `select`. Its only avialable on the\n * chained version.\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {Array.<string | Regexp>} projField - An array of column names in string or regular expression.\n * @param {Object} [config] - An optional config to control the creation of new DataModel\n * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - Mode of the projection\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const project = (...args) => dm => dm.project(...args);\n\n/**\n * This is functional version of binnig operator. Binning happens on a measure field based on a binning configuration.\n * Binning in DataModel does not aggregate the number of rows present in DataModel instance after binning, it just adds\n * a new field with the binned value. Refer binning {@link example_of_binning | example} to have a intuition of what\n * binning is and the use case.\n *\n * Binning can be configured by\n * - providing custom bin configuration with non uniform buckets\n * - providing bin count\n * - providing each bin size\n *\n * When custom buckets are provided as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const buckets = {\n *      start: 30\n *      stops: [80, 100, 110]\n *  };\n *  const config = { buckets, name: 'binnedHP' }\n *  const binFn = bin('horsepower', config);\n *  const binnedDm = binFn(dm);\n *\n * @text\n * When `binCount` is defined as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const config = { binCount: 5, name: 'binnedHP' }\n *  const binFn = bin('horsepower', config);\n *  const binnedDm = binFn(Dm);\n *\n * @text\n * When `binSize` is defined as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const config = { binSize: 200, name: 'binnedHorsepower' }\n *  const binnedDm = dataModel.bin('horsepower', config);\n *  const binnedDm = binFn(Dm);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {String} name Name of measure which will be used to create bin\n * @param {Object} config Config required for bin creation\n * @param {Array.<Number>} config.bucketObj.stops Defination of bucket ranges. Two subsequent number from arrays\n *      are picked and a range is created. The first number from range is inclusive and the second number from range\n *      is exclusive.\n * @param {Number} [config.bucketObj.startAt] Force the start of the bin from a particular number.\n *      If not mentioned, the start of the bin or the lower domain of the data if stops is not mentioned, else its\n *      the first value of the stop.\n * @param {Number} config.binSize Bucket size for each bin\n * @param {Number} config.binCount Number of bins which will be created\n * @param {String} config.name Name of the new binned field to be created\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const bin = (...args) => dm => dm.bin(...args);\n\n/**\n * This is functional version of `groupBy` operator.Groups the data using particular dimensions and by reducing\n * measures. It expects a list of dimensions using which it projects the datamodel and perform aggregations to reduce\n * the duplicate tuples. Refer this {@link link_to_one_example_with_group_by | document} to know the intuition behind\n * groupBy.\n *\n * DataModel by default provides definition of few {@link reducer | Reducers}.\n * {@link ReducerStore | User defined reducers} can also be registered.\n *\n * This is the chained implementation of `groupBy`.\n * `groupBy` also supports {@link link_to_compose_groupBy | composability}\n *\n * @example\n * const groupBy = DataModel.Operators.groupBy;\n * const groupedFn = groupBy(['Year'], { horsepower: 'max' } );\n * groupedDM = groupByFn(dm);\n *\n * @public\n *\n * @param {Array.<string>} fieldsArr - Array containing the name of dimensions\n * @param {Object} [reducers={}] - A map whose key is the variable name and value is the name of the reducer. If its\n *      not passed, or any variable is ommitted from the object, default aggregation function is used from the\n *      schema of the variable.\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const groupBy = (...args) => dm => dm.groupBy(...args);\n\n/**\n * Enables composing operators to run multiple operations and save group of operataion as named opration on a DataModel.\n * The resulting DataModel will be the result of all the operation provided. The operations provided will be executed in\n * a serial manner ie. result of one operation will be the input for the next operations (like pipe operator in unix).\n *\n * Suported operations in compose are\n * - `select`\n * - `project`\n * - `groupBy`\n * - `bin`\n * - `compose`\n *\n * @example\n * const compose = DataModel.Operators.compose;\n * const select = DataModel.Operators.select;\n * const project = DataModel.Operators.project;\n *\n * let composedFn = compose(\n *    select(fields => fields.netprofit.value <= 15),\n *    project(['netprofit', 'netsales']));\n *\n * const dataModel = new DataModel(data1, schema1);\n *\n * let composedDm = composedFn(dataModel);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {Array.<Operators>} operators: An array of operation that will be applied on the\n * datatable.\n *\n * @returns {DataModel} Instance of resultant DataModel\n */\nexport const compose = (...operations) =>\n    (dm, config = { saveChild: true }) => {\n        let currentDM = dm;\n        let frstChild;\n        const derivations = [];\n        const saveChild = config.saveChild;\n\n        operations.forEach((operation) => {\n            currentDM = operation(currentDM);\n            derivations.push(...currentDM._derivation);\n            if (!frstChild) {\n                frstChild = currentDM;\n            }\n        });\n\n        saveChild && currentDM.addParent(dm, derivations);\n        if (derivations.length > 1) {\n            frstChild.dispose();\n        }\n\n        return currentDM;\n    };\n","/**\n * Wrapper on calculateVariable() method of DataModel to behave\n * the pure-function functionality.\n *\n * @param {Array} args - The argument list.\n * @return {any} Returns the returned value of calling function.\n */\nexport const calculateVariable = (...args) => dm => dm.calculateVariable(...args);\n\n/**\n * Wrapper on sort() method of DataModel to behave\n * the pure-function functionality.\n *\n * @param {Array} args - The argument list.\n * @return {any} Returns the returned value of calling function.\n */\nexport const sort = (...args) => dm => dm.sort(...args);\n","import { crossProduct } from './cross-product';\nimport { naturalJoinFilter } from './natural-join-filter-function';\n\nexport function naturalJoin (dataModel1, dataModel2) {\n    return crossProduct(dataModel1, dataModel2, naturalJoinFilter(dataModel1, dataModel2), true);\n}\n"],"sourceRoot":""}