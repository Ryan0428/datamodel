---
  title: "Compose"
  description: "Documented Methods"
  sections: 
    - 
      type: "markdown-section"
      content: "DataModel\n\nDataModel's opearators are exposed as composable functional operators as well as chainable operators. Chainable\noperators are called on the instances of [Datamodel](Datamodel) class.\n\nThose same operators can be used as composable operators from `DataModel.Operators` namespace.\n\nThe procedure of invoking all these operators is consistent. All these operators when called with the argument\nreturns a function which expects a DataModel instance."
    - 
      type: "markdown-section"
      content: "DataModel\n\nThis is functional version of selection operator. Selection is a row filtering operation. It takes\n[predicate](SelectionPredicate) for filtering criteria and returns a function. The returned function is called\nwith the DataModel instance on which the action needs to be performed.\n\n[SelectionPredicate](SelectionPredicate) is a function which returns a boolean value. For selection opearation the selection\nfunction is called for each row of DataModel instance with the current row passed as argument.\n\nAfter executing [SelectionPredicate](SelectionPredicate) the rows are labeled as either an entry of selection set or an entry\nof rejection set.\n\n[FilteringMode](FilteringMode) operates on the selection and rejection set to determine which one would reflect in the\nresulatant datamodel."
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">selectFn</td>\n                <td><p>SelectionPredicate</p> </td>\n                <td><p>Predicate function which is called for each row with the current row      <code>function (row, i)  { ... }</code></p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">config</td>\n                <td><p>Object</p> </td>\n                <td><p>The configuration object to control the inclusion exclusion of a row in resultant      DataModel instance<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead></p> <tr>                 <td class=\"param-name\">mode</td>                 <td><p>FilteringMode</p> </td>                 <td><p>The mode of the selection</p> </td>             </tr></table></td>\n            </tr></table>"
    - 
      type: "code-section"
      content: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const select = DataModel.Operators.select;\n usaCarsFn = select(fields => fields.Origin.value === 'USA');\n outputDM = usaCarsFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
      preamble: []
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const select = DataModel.Operators.select;\n usaCarsFn = select(fields => fields.Origin.value === 'USA');\n outputDM = usaCarsFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "Info"
      content: 
        subType: "warning"
        title: "Note"
        description: "[Warn] Selection and rejection set is only a logical idea for concept explanation purpose."
    - 
      type: "markdown-section"
      content: "<a name=PreparatorFunction></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">PreparatorFunction:</span>Function which expects an instance of DataModel on which the operator needs to be\n     applied."
    - 
      type: "markdown-section"
      content: "DataModel\n\nThis is functional version of projection operator. Projection is a column (field) filtering operation. It expects\nlist of fields name and either include those or exclude those based on [FilteringMode](FilteringMode) on the resultant\ndataModel. It returns a function which is called with the DataModel instance on which the action needs to be\nperformed.\n\nProjection expects array of fields name based on which it creates the selection and rejection set. All the field\nwhose name is present in array goes in selection set and rest of the fields goes in rejection set.\n\n[FilteringMode](FilteringMode) operates on the selection and rejection set to determine which one would reflect in the\nresulatant datamodel."
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">projField</td>\n                <td><p>Array&lt;(string|Regexp)&gt;</p> </td>\n                <td><p>An array of column names in string or regular expression.</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">config</td>\n                <td><p>Object</p> </td>\n                <td><p>An optional config to control the creation of new DataModel<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead></p> <tr>                 <td class=\"param-name\">mode</td>                 <td><p>FilteringMode</p> </td>                 <td><p>Mode of the projection</p> </td>             </tr></table></td>\n            </tr></table>"
    - 
      type: "code-section"
      content: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const project = DataModel.Operators.project;\n usaCarsFn = project(['Name'], { mode: DataModel.FilteringMode.INVERSE });\n outputDM = usaCarsFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
      preamble: []
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const project = DataModel.Operators.project;\n usaCarsFn = project(['Name'], { mode: DataModel.FilteringMode.INVERSE });\n outputDM = usaCarsFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "Info"
      content: 
        subType: "warning"
        title: "Note"
        description: "Selection and rejection set is only a logical idea for concept explanation purpose."
    - 
      type: "markdown-section"
      content: "<a name=PreparatorFunction></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">PreparatorFunction:</span>Function which expects an instance of DataModel on which the operator needs to be\n     applied."
    - 
      type: "markdown-section"
      content: "DataModel\n\nThis is functional version of `groupBy` operator. This operator groups the data using particular dimensions and by\nreducing measures. It expects a list of dimensions using which it projects the datamodel and perform aggregations to\nreduce the duplicate tuples. Refer [this document](muzedocsdatamodeloperatorsgroupby) to know the\nintuition behind groupBy.\n\nDataModel by default provides definition of few [Reducers](reducer).\n[User defined reducers](ReducerStore) can also be registered."
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">fieldsArr</td>\n                <td><p>Array of string</p> </td>\n                <td><p>Array containing the name of dimensions</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">reducers</td>\n                <td><p>Object</p> </td>\n                <td><p>A map whose key is the variable name and value is the name of the reducer. If its      not passed, or any variable is ommitted from the object, default aggregation function is used from the      schema of the variable.</p> </td>\n            </tr></table>"
    - 
      type: "code-section"
      content: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n\n const groupBy = DataModel.Operators.groupBy;\n const groupedFn = groupBy(['Year'], { horsepower: 'max' } );\n const outputDM = groupByFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
      preamble: []
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n\n const groupBy = DataModel.Operators.groupBy;\n const groupedFn = groupBy(['Year'], { horsepower: 'max' } );\n const outputDM = groupByFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<a name=PreparatorFunction></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">PreparatorFunction:</span>Function which expects an instance of DataModel on which the operator needs to be\n     applied."
    - 
      type: "markdown-section"
      content: "Operators\n\nIt enables you to create new operator by composing existing operators. The newly created operator is used like any\nother operator. The operations provided will be executed in a serial manner ie. result of one operation will be the\ninput for the next operations (like pipe operator in unix).\n\nCompose has added benefits which chaining does not provide. Like, if there are group of operators are involved to\ntransform data, chaining would create so intermediate DataModel instances. If `compose` is used no intermediate\nDataModels are created.\n\nSuported operators in compose are\n- `select`\n- `project`\n- `groupBy`\n- `bin`\n- Any operator created using compose `compose`"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">operators</td>\n                <td><p>Array of Operators</p> </td>\n                <td><p>An array of operation that will be applied on the datatable.</p> </td>\n            </tr></table>"
    - 
      type: "code-section"
      content: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const compose = DataModel.Operators.compose;\n const select = DataModel.Operators.select;\n const project = DataModel.Operators.project;\n\n let lowCylCarsFromUSADM= compose(\n     select(fields => fields.Origin.value === 'USA' && fields.Cylinders.value === '4' ),\n     project(['Origin', 'Cylinders'], { mode: DataModel.FilteringMode.INVERSE })\n );\n\n const outputDM = lowCylCarsFromUSADM(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
      preamble: []
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const compose = DataModel.Operators.compose;\n const select = DataModel.Operators.select;\n const project = DataModel.Operators.project;\n\n let lowCylCarsFromUSADM= compose(\n     select(fields => fields.Origin.value === 'USA' && fields.Cylinders.value === '4' ),\n     project(['Origin', 'Cylinders'], { mode: DataModel.FilteringMode.INVERSE })\n );\n\n const outputDM = lowCylCarsFromUSADM(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<a name=PreparatorFunction></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">PreparatorFunction:</span>Function which expects an instance of DataModel on which the operator needs to be\n     applied."
