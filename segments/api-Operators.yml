---
  title: "Operators"
  description: "Documented Methods"
  sections: 
    - 
      type: "markdown-section"
      content: "## <a name=select></a> <span style=\"font-family: Source Code Pro; font-weight: 500;color: #eb5757;\">select</span>\n\nThis is functional version of selection operator. Selection is a row filtering operation. It takes\n[predicate](/muze/docs/api-selecitonpredicate) for filtering criteria and returns a function. The returned\nfunction is called with the DataModel instance on which the action needs to be performed.\n\n[SelectionPredicate](/muze/docs/api-selecitonpredicate) is a function which returns a boolean value. For\nselection opearation the selection function is called for each row of DataModel instance with the current row passed\nas argument.\n\nAfter executing [SelectionPredicate](/muze/docs/api-selecitonpredicate) the rows are labeled as either an\nentry of selection set or an entry of rejection set.\n\n[FilteringMode](/muze/docs/api-Enums#FilteringMode) operates on the selection and rejection set to determine\nwhich one would reflect in the resulatant datamodel."
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const select = DataModel.Operators.select;\n usaCarsFn = select(fields => fields.Origin.value === 'USA');\n outputDM = usaCarsFn(dm);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const select = DataModel.Operators.select;\n usaCarsFn = select(fields => fields.Origin.value === 'USA');\n outputDM = usaCarsFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">selectFn</td>\n                <td><p>SelectionPredicate</p> </td>\n                <td><p>Predicate function which is called for each row with the current row      <p><code>function (row, i)  { ... }</code></p></p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">config</td>\n                <td><p>Object</p> </td>\n                <td><p>The configuration object to control the inclusion exclusion of a row in resultant      DataModel instance<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead></p> <tr>                 <td class=\"param-name\">mode</td>                 <td><p>FilteringMode</p> </td>                 <td><p>The mode of the selection</p> </td>             </tr></table></td>\n            </tr></table>"
    - 
      type: "Info"
      content: 
        subType: "warning"
        title: "Note"
        description: "[Warn] Selection and rejection set is only a logical idea for concept explanation purpose."
    - 
      type: "markdown-section"
      content: "<a name=PreparatorFunction></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[PreparatorFunction](PreparatorFunction):&nbsp;</span>Function which expects an instance of DataModel on which the operator needs to be\n     applied."
    - 
      type: "markdown-section"
      content: "## <a name=project></a> <span style=\"font-family: Source Code Pro; font-weight: 500;color: #eb5757;\">project</span>\n\nThis is functional version of projection operator. Projection is a column (field) filtering operation. It expects\nlist of fields name and either include those or exclude those based on\n[FilteringMode](/muze/docs/api-Enums#FilteringMode) on the resultant dataModel. It returns a function which is\ncalled with the DataModel instance on which the action needs to be performed.\n\nProjection expects array of fields name based on which it creates the selection and rejection set. All the field\nwhose name is present in array goes in selection set and rest of the fields goes in rejection set.\n\n[FilteringMode](/muze/docs/api-Enums#FilteringMode) operates on the selection and rejection set to determine\nwhich one would reflect in the resulatant datamodel."
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const project = DataModel.Operators.project;\n usaCarsFn = project(['Name'], { mode: DataModel.FilteringMode.INVERSE });\n outputDM = usaCarsFn(dm);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const project = DataModel.Operators.project;\n usaCarsFn = project(['Name'], { mode: DataModel.FilteringMode.INVERSE });\n outputDM = usaCarsFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">projField</td>\n                <td><p>Array&lt;(string|Regexp)&gt;</p> </td>\n                <td><p>An array of column names in string or regular expression.</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">config</td>\n                <td><p>Object</p> </td>\n                <td><p>An optional config to control the creation of new DataModel<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead></p> <tr>                 <td class=\"param-name\">mode</td>                 <td><p>FilteringMode</p> </td>                 <td><p>Mode of the projection</p> </td>             </tr></table></td>\n            </tr></table>"
    - 
      type: "Info"
      content: 
        subType: "warning"
        title: "Note"
        description: "Selection and rejection set is only a logical idea for concept explanation purpose."
    - 
      type: "markdown-section"
      content: "<a name=PreparatorFunction></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[PreparatorFunction](PreparatorFunction):&nbsp;</span>Function which expects an instance of DataModel on which the operator needs to be\n     applied."
    - 
      type: "markdown-section"
      content: "## <a name=groupBy></a> <span style=\"font-family: Source Code Pro; font-weight: 500;color: #eb5757;\">groupBy</span>\n\nThis is functional version of `groupBy` operator. This operator groups the data using particular dimensions and by\nreducing measures. It expects a list of dimensions using which it projects the datamodel and perform aggregations to\nreduce the duplicate tuples. Refer [this document](/muze/docs/datamodel-operators#groupby) to know the\nintuition behind groupBy.\n\nDataModel by default provides definition of few [Reducers](/muze/docs/api-reducer).\n[User defined reducers](/muze/docs/api-reducerstore) can also be registered."
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n\n const groupBy = DataModel.Operators.groupBy;\n const groupedFn = groupBy(['Year'], { horsepower: 'max' } );\n const outputDM = groupedFn(dm);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n\n const groupBy = DataModel.Operators.groupBy;\n const groupedFn = groupBy(['Year'], { horsepower: 'max' } );\n const outputDM = groupedFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">fieldsArr</td>\n                <td><p>Array of string</p> </td>\n                <td><p>Array containing the name of dimensions</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">reducers</td>\n                <td><p>Object</p> </td>\n                <td><p>A map whose key is the variable name and value is the name of the reducer. If its      not passed, or any variable is ommitted from the object, default aggregation function is used from the      schema of the variable.</p> </td>\n            </tr></table>"
    - 
      type: "markdown-section"
      content: "<a name=PreparatorFunction></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[PreparatorFunction](PreparatorFunction):&nbsp;</span>Function which expects an instance of DataModel on which the operator needs to be\n     applied."
    - 
      type: "markdown-section"
      content: "## <a name=compose></a> <span style=\"font-family: Source Code Pro; font-weight: 500;color: #eb5757;\">compose</span>\n\nIt enables you to create new operator by composing existing operators. The newly created operator is used like any\nother operator. The operations provided will be executed in a serial manner ie. result of one operation will be the\ninput for the next operations (like pipe operator in unix).\n\nCompose has added benefits which chaining does not provide. Like, if there are group of operators are involved to\ntransform data, chaining would create so intermediate DataModel instances. If `compose` is used no intermediate\nDataModels are created.\n\nSuported operators in compose are\n- `select`\n- `project`\n- `groupBy`\n- `bin`\n- Any operator created using compose `compose`"
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const compose = DataModel.Operators.compose;\n const select = DataModel.Operators.select;\n const project = DataModel.Operators.project;\n\n let lowCylCarsFromUSADM= compose(\n     select(fields => fields.Origin.value === 'USA' && fields.Cylinders.value === '4' ),\n     project(['Origin', 'Cylinders'], { mode: DataModel.FilteringMode.INVERSE })\n );\n\n const outputDM = lowCylCarsFromUSADM(dm);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n const compose = DataModel.Operators.compose;\n const select = DataModel.Operators.select;\n const project = DataModel.Operators.project;\n\n let lowCylCarsFromUSADM= compose(\n     select(fields => fields.Origin.value === 'USA' && fields.Cylinders.value === '4' ),\n     project(['Origin', 'Cylinders'], { mode: DataModel.FilteringMode.INVERSE })\n );\n\n const outputDM = lowCylCarsFromUSADM(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">operators</td>\n                <td><p>Array of Operators</p> </td>\n                <td><p>An array of operation that will be applied on the datatable.</p> </td>\n            </tr></table>"
    - 
      type: "markdown-section"
      content: "<a name=PreparatorFunction></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[PreparatorFunction](PreparatorFunction):&nbsp;</span>Function which expects an instance of DataModel on which the operator needs to be\n     applied."
    - 
      type: "markdown-section"
      content: "<h2><span style=\"font-family: Source Code Pro;font-weight:500;font-size:24px;color: #eb5757\"><a name=difference></a> difference </span></h2>\n\nDifference operator is written as `(A - B)` where **A** and **B** are instances of\n[DataModel](/muze/docs/api-datamodel). The result of `difference` is an instance of\n[DataModel](/muze/docs/api-datamodel) which includes tuples which are present in **A** and not in **B**.\nFor `difference` to work schema of both [DataModel](/muze/docs/api-datamodel) has to be same."
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates a DataModel instance only including USA. Using chained version for conciseness.\n const usaMakerDM = dm.select(fields => fields.Origin.value === 'USA');\n\n const difference = DataModel.Operators.difference;\n outputDM = difference(dm, usaMakerDM);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: "     const data = params[0];"
        - 
          preTag: "     const schema = params[1];"
        - 
          preTag: "     const DataModel = muze.DataModel;"
        - 
          preTag: "     const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n     const data = params[0];\n     const schema = params[1];\n     const DataModel = muze.DataModel;\n     const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates a DataModel instance only including USA. Using chained version for conciseness.\n const usaMakerDM = dm.select(fields => fields.Origin.value === 'USA');\n\n const difference = DataModel.Operators.difference;\n outputDM = difference(dm, usaMakerDM);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">leftDM</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of <a href=\"DataModel\">DataModel</a> from which the difference will be calculated. For the      notation <code>(A - B)</code>, <strong>A</strong> is the leftDM</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">rightDM</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of <a href=\"DataModel\">DataModel</a> which will be used to calculate the difference from the      leftDM. For the notation <code>(A - B)</code>, <strong>B</strong> is the rightDM.</p> </td>\n            </tr></table>"
    - 
      type: "markdown-section"
      content: "<a name=DataModel></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[DataModel](DataModel):&nbsp;</span>New [DataModel](DataModel) instance with the result of the operation."
    - 
      type: "markdown-section"
      content: "<h2><span style=\"font-family: Source Code Pro;font-weight:500;font-size:24px;color: #eb5757\"><a name=join></a> join </span></h2>\n\nPerforms [crossproduct](https://en.wikipedia.org/wiki/Cartesian_product) between two\n[DataModel](/muze/docs/api-datamodel) instances with an optional predicate which determines which tuples\nshould be included and returns a new [DataModel](/muze/docs/api-datamodel) instance containing the results.\nThis operation is also called theta join.\n\nCross product takes two set and create one set where each value of one set is paired with each value of another\nset.\n\nThis method takes an optional predicate which filters the generated result rows. The predicate is called for\nevery tuple. If the predicate returns true the combined row is included in the resulatant table."
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, which will be joined.\n let makerDM = dm.groupBy(['Origin', 'Maker']).project(['Origin', 'Maker']);\n let nameDM = dm.project(['Name','Miles_per_Gallon']);\n\n const join = DataModel.Operators.join;\n let outputDM = join(makerDM, nameDM,\n     (makerDM, nameDM) => makerDM.Maker.value === nameDM.Name.value.split(/\\s/)[0]);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, which will be joined.\n let makerDM = dm.groupBy(['Origin', 'Maker']).project(['Origin', 'Maker']);\n let nameDM = dm.project(['Name','Miles_per_Gallon']);\n\n const join = DataModel.Operators.join;\n let outputDM = join(makerDM, nameDM,\n     (makerDM, nameDM) => makerDM.Maker.value === nameDM.Name.value.split(/\\s/)[0]);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">leftDM</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of DataModel</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">rightDM</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of DataModel</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">filterFn</td>\n                <td><p>SelectionPredicate</p> </td>\n                <td><p>The predicate function that will filter the result of the crossProduct.</p> </td>\n            </tr></table>"
    - 
      type: "markdown-section"
      content: "<a name=DataModel></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[DataModel](DataModel):&nbsp;</span>New DataModel instance created after joining."
    - 
      type: "markdown-section"
      content: "## <a name=DataModel></a> <span style=\"font-family: Source Code Pro; font-weight: 500;color: #eb5757;\">DataModel</span>\n\n[Natural join](https://www.geeksforgeeks.org/extended-operators-in-relational-algebra) is a special kind\nof joining where filtering of rows are performed internally by resolving common fields are from both table and\nthe rows with common value are included."
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, which will be joined. Used chained\n // operator for conciseness.\n const makerDM = dm.groupBy(['Origin', 'Maker']).project(['Origin', 'Maker']);\n const nameDM = dm.project(['Name','Miles_per_Gallon'])\n\n const naturalJoin = DataModel.Operators.naturalJoin;\n const outputDM = naturalJoin(makerDM, nameDM);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: "     const data = params[0];"
        - 
          preTag: "     const schema = params[1];"
        - 
          preTag: "     const DataModel = muze.DataModel;"
        - 
          preTag: "     const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n     const data = params[0];\n     const schema = params[1];\n     const DataModel = muze.DataModel;\n     const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, which will be joined. Used chained\n // operator for conciseness.\n const makerDM = dm.groupBy(['Origin', 'Maker']).project(['Origin', 'Maker']);\n const nameDM = dm.project(['Name','Miles_per_Gallon'])\n\n const naturalJoin = DataModel.Operators.naturalJoin;\n const outputDM = naturalJoin(makerDM, nameDM);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">leftDM</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of DataModel</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">rightDM</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of DataModel</p> </td>\n            </tr></table>"
    - 
      type: "markdown-section"
      content: "<a name=DataModel></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[DataModel](DataModel):&nbsp;</span>New DataModel instance with joined data"
    - 
      type: "markdown-section"
      content: "<h2><span style=\"font-family: Source Code Pro;font-weight:500;font-size:24px;color: #eb5757\"><a name=leftOuterJoin></a> leftOuterJoin </span></h2>\n\n[Left outer join](https://www.geeksforgeeks.org/extended-operators-in-relational-algebra/) between two\n[DataModel](/muze/docs/api-datamodel) instances is a kind of join that ensures that all the tuples from the\nleft [DataModel](/muze/docs/api-datamodel) are present in the resulatant\n[DataModel](/muze/docs/api-datamodel). This operator takes a predicate which gets called for every\ncombination of tuples (created by cartesian product). Based on the value of predicate the equality is established\nbetween two DataModel."
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, which will be joined using left outer\n // join.\n let makerDM = dm.groupBy(['Origin', 'Maker']).project(['Origin', 'Maker']);\n let nameDM = dm.project(['Name','Miles_per_Gallon']);\n\n const leftOuterJoin = DataModel.Operators.leftOuterJoin;\n let outputDM = leftOuterJoin(makerDM, nameDM,\n     (makerDM, nameDM) => makerDM.Maker.value === nameDM.Name.value.split(/\\s/)[0]);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, which will be joined using left outer\n // join.\n let makerDM = dm.groupBy(['Origin', 'Maker']).project(['Origin', 'Maker']);\n let nameDM = dm.project(['Name','Miles_per_Gallon']);\n\n const leftOuterJoin = DataModel.Operators.leftOuterJoin;\n let outputDM = leftOuterJoin(makerDM, nameDM,\n     (makerDM, nameDM) => makerDM.Maker.value === nameDM.Name.value.split(/\\s/)[0]);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">leftDm</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of DataModel</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">rightDm</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of DataModel</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">filterFn</td>\n                <td><p>SelectionPredicate</p> </td>\n                <td><p>The predicate function that will filter the result of the crossProduct.</p> </td>\n            </tr></table>"
    - 
      type: "markdown-section"
      content: "<a name=DataModel></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[DataModel](DataModel):&nbsp;</span>New DataModel instance created after the left outer join operation."
    - 
      type: "markdown-section"
      content: "<h2><span style=\"font-family: Source Code Pro;font-weight:500;font-size:24px;color: #eb5757\"><a name=rightOuterJoin></a> rightOuterJoin </span></h2>\n\n[Right outer join](https://www.geeksforgeeks.org/extended-operators-in-relational-algebra/) between two\n[DataModel](/muze/docs/api-datamodel) instances is a kind of join that ensures that all the tuples from the\nright [DataModel](/muze/docs/api-datamodel) are present in the resulatant\n[DataModel](/muze/docs/api-datamodel). This operator takes a predicate which gets called for every\ncombination of tuples (created by cartesian product). Based on the value of predicate the equality is established\nbetween two DataModel."
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, which will be joined using left outer\n // join.\n let makerDM = dm.groupBy(['Origin', 'Maker']).project(['Origin', 'Maker']);\n let nameDM = dm.project(['Name','Miles_per_Gallon']);\n\n const rightOuterJoin = DataModel.Operators.rightOuterJoin;\n let outputDM = rightOuterJoin(makerDM, nameDM,\n     (makerDM, nameDM) => makerDM.Maker.value === nameDM.Name.value.split(/\\s/)[0]);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, which will be joined using left outer\n // join.\n let makerDM = dm.groupBy(['Origin', 'Maker']).project(['Origin', 'Maker']);\n let nameDM = dm.project(['Name','Miles_per_Gallon']);\n\n const rightOuterJoin = DataModel.Operators.rightOuterJoin;\n let outputDM = rightOuterJoin(makerDM, nameDM,\n     (makerDM, nameDM) => makerDM.Maker.value === nameDM.Name.value.split(/\\s/)[0]);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">leftDm</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of DataModel</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">rightDm</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of DataModel</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">filterFn</td>\n                <td><p>SelectionPredicate</p> </td>\n                <td><p>The predicate function that will filter the result of the crossProduct.</p> </td>\n            </tr></table>"
    - 
      type: "markdown-section"
      content: "<a name=DataModel></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[DataModel](DataModel):&nbsp;</span>New DataModel instance created after the left outer join operation."
    - 
      type: "markdown-section"
      content: "<h2><span style=\"font-family: Source Code Pro;font-weight:500;font-size:24px;color: #eb5757\"><a name=fullOuterJoin></a> fullOuterJoin </span></h2>\n\n[Full outer join](https://www.geeksforgeeks.org/extended-operators-in-relational-algebra/) between two\n[DataModel](/muze/docs/api-datamodel) instances is a kind of join that ensures that all the tuples from the\nleft [DataModel](/muze/docs/api-datamodel) and right [DataModel](/muze/docs/api-datamodel) are present\nin the resulatant [DataModel](/muze/docs/api-datamodel). This operator takes a predicate which gets\ncalled for every combination of tuples (created by cartesian product). Based on the value of predicate the equality\nis established between two DataModel."
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, which will be joined using left outer\n // join.\n let makerDM = dm.groupBy(['Origin', 'Maker']).project(['Origin', 'Maker']);\n let nameDM = dm.project(['Name','Miles_per_Gallon']);\n\n const fullOuterJoin = DataModel.Operators.fullOuterJoin;\n let outputDM = fullOuterJoin(makerDM, nameDM,\n     (makerDM, nameDM) => makerDM.Maker.value === nameDM.Name.value.split(/\\s/)[0]);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, which will be joined using left outer\n // join.\n let makerDM = dm.groupBy(['Origin', 'Maker']).project(['Origin', 'Maker']);\n let nameDM = dm.project(['Name','Miles_per_Gallon']);\n\n const fullOuterJoin = DataModel.Operators.fullOuterJoin;\n let outputDM = fullOuterJoin(makerDM, nameDM,\n     (makerDM, nameDM) => makerDM.Maker.value === nameDM.Name.value.split(/\\s/)[0]);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">leftDm</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of DataModel</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">rightDm</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Instance of DataModel</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">filterFn</td>\n                <td><p>SelectionPredicate</p> </td>\n                <td><p>The predicate function that will filter the result of the crossProduct.</p> </td>\n            </tr></table>"
    - 
      type: "markdown-section"
      content: "<a name=DataModel></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[DataModel](DataModel):&nbsp;</span>New DataModel instance created after the left outer join operation."
    - 
      type: "markdown-section"
      content: "## <a name=calculateVariable></a> <span style=\"font-family: Source Code Pro; font-weight: 500;color: #eb5757;\">calculateVariable</span>\n\nCreates a new variable calculated from existing variable. This method expects definition of the newly created\nvariable and a function which resolves value of the new variable from existing variables.\n\nThis operator is not compose supported.\n\nCreates a new measure based on existing variables"
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n\n const calculateVariable = DataModel.Operators.calculateVariable\n const creatorFn = calculateVariable({\n     name: 'powerToWeight',\n     type: 'measure' // Schema of variable\n }, ['Horsepower', 'Weight_in_lbs', (hp, weight) => hp / weight ]);\n const outputDM = creatorFn(dm);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n\n const calculateVariable = DataModel.Operators.calculateVariable\n const creatorFn = calculateVariable({\n     name: 'powerToWeight',\n     type: 'measure' // Schema of variable\n }, ['Horsepower', 'Weight_in_lbs', (hp, weight) => hp / weight ]);\n const outputDM = creatorFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n\n const calculateVariable = DataModel.Operators.calculateVariable;\n const creatorFn = calculateVariable(\n    {\n      name: 'Efficiency',\n      type: 'dimension'\n    }, ['Horsepower', (hp) => {\n     if (hp < 80) { return 'low'; }\n     else if (hp < 120) { return 'moderate'; }\n     else { return 'high' }\n }]);\n  const outputDM = creatorFn(dm);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new muze.DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new muze.DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n\n const calculateVariable = DataModel.Operators.calculateVariable;\n const creatorFn = calculateVariable(\n    {\n      name: 'Efficiency',\n      type: 'dimension'\n    }, ['Horsepower', (hp) => {\n     if (hp < 80) { return 'low'; }\n     else if (hp < 120) { return 'moderate'; }\n     else { return 'high' }\n }]);\n  const outputDM = creatorFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">schema</td>\n                <td><p>Schema</p> </td>\n                <td><p>Schema of newly defined variable</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">resolver</td>\n                <td><p>VariableResolver</p> </td>\n                <td><p>Resolver format to resolve the current variable</p> </td>\n            </tr></table>"
    - 
      type: "markdown-section"
      content: "<a name=PreparatorFunction></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[PreparatorFunction](PreparatorFunction):&nbsp;</span>Function which expects an instance of DataModel on which the operator needs to be\n     applied."
    - 
      type: "markdown-section"
      content: "## <a name=sort></a> <span style=\"font-family: Source Code Pro; font-weight: 500;color: #eb5757;\">sort</span>\n\nPerforms sorting according to the specified sorting details. Like every other operator it doesn't mutate the current\nDataModel instance on which it was called, instead returns a new DataModel instance containing the sorted data.\n\nThis operator support multi level sorting by listing the variables using which sorting needs to be performed and\nthe type of sorting `ASC` or `DESC`.\n\nIn the following example, data is sorted by `Origin` field in `DESC` order in first level followed by another level\nof sorting by `Acceleration` in `ASC` order."
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n\n const sort = DataModel.Operators.sort;\n const preparatorFn = sort([\n     ['Origin', 'DESC'],\n     ['Acceleration'] // Default value is ASC\n ]);\n const outputDM = preparatorFn(dm);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the DataModel variable.\n\n const sort = DataModel.Operators.sort;\n const preparatorFn = sort([\n     ['Origin', 'DESC'],\n     ['Acceleration'] // Default value is ASC\n ]);\n const outputDM = preparatorFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted\n // from muze namespace and assigned to DataModel variable.\n const avg = DataModel.Stats.avg;\n const sort = DataModel.Operators.sort;\n const preparatorFn = sort([\n     ['Origin', ['Acceleration', (a, b) => avg(a.Acceleration) - avg(b.Acceleration)]]\n ]);\n const outputDM = preparatorFn(dm);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: "  const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new muze.DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n  const DataModel = muze.DataModel;\n const dm = new muze.DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted\n // from muze namespace and assigned to DataModel variable.\n const avg = DataModel.Stats.avg;\n const sort = DataModel.Operators.sort;\n const preparatorFn = sort([\n     ['Origin', ['Acceleration', (a, b) => avg(a.Acceleration) - avg(b.Acceleration)]]\n ]);\n const outputDM = preparatorFn(dm);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">sortingDetails</td>\n                <td><p>Array of Array</p> </td>\n                <td><p>Sorting details based on which the sorting will be performed.</p> </td>\n            </tr></table>"
    - 
      type: "markdown-section"
      content: "<a name=PreparatorFunction></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[PreparatorFunction](PreparatorFunction):&nbsp;</span>Function which expects an instance of DataModel on which the operator needs to be\n     applied."
    - 
      type: "markdown-section"
      content: "<h2><span style=\"font-family: Source Code Pro;font-weight:500;font-size:24px;color: #eb5757\"><a name=union></a> union </span></h2>\n\nUnion operation can be termed as vertical stacking of all rows from both the DataModel instances, provided that both\nof the [DataModel](DataModel) instances should have same column names."
    - 
      type: "code-section"
      content: " // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, one only for european cars,\n // another for cars from USA. Used the chain operation here for conciseness.\n const usaMakerDM = dm.select(fields => fields.Origin.value === 'USA');\n const euroMakerDM = dm.select(fields => fields.Origin.value === 'Europe');\n\n const union = DataModel.Operators.union;\n const outputDM = union(usaMakerDM, euroMakerDM);"
      preamble: 
        - 
          preTag: " Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {"
        - 
          preTag: " const data = params[0];"
        - 
          preTag: " const schema = params[1];"
        - 
          preTag: " const DataModel = muze.DataModel;"
        - 
          preTag: " const dm = new DataModel(data, schema);"
        - 
          endTag: " printDM(outputDM);"
        - 
          endTag: " });"
      preambleWithContent: "//@preamble_start\n Promise.all([loadData('/static/cars.json'), loadData('/static/cars-schema.json')]).then(function (params) {\n const data = params[0];\n const schema = params[1];\n const DataModel = muze.DataModel;\n const dm = new DataModel(data, schema);\n //@preamble_end\n // DataModel instance is created from https://www.charts.com/static/cars.json data,\n // https://www.charts.com/static/cars-schema.json schema and assigned to variable dm. DataModel is extracted from\n // muze namespace and assigned to the variable DataModel.\n\n // Creates two small DataModel instance from the original DataModel instance, one only for european cars,\n // another for cars from USA. Used the chain operation here for conciseness.\n const usaMakerDM = dm.select(fields => fields.Origin.value === 'USA');\n const euroMakerDM = dm.select(fields => fields.Origin.value === 'Europe');\n\n const union = DataModel.Operators.union;\n const outputDM = union(usaMakerDM, euroMakerDM);\n //@preamble_start\n printDM(outputDM);\n });\n //@preamble_end"
    - 
      type: "markdown-section"
      content: "<p class=\"sub-header\">Parameters:</p>\n<table><thead><tr><td>Name</td><td>Type</td><td>Description</td></tr></thead>\n<tr>\n                <td class=\"param-name\">topDM</td>\n                <td><p>DataModel</p> </td>\n                <td><p>One of the two operands of union. Instance of DataModel.</p> </td>\n            </tr>\n<tr>\n                <td class=\"param-name\">bottomDM</td>\n                <td><p>DataModel</p> </td>\n                <td><p>Another operands of union. Instance of DataModel.</p> </td>\n            </tr></table>"
    - 
      type: "markdown-section"
      content: "<a name=DataModel></a><p class=\"sub-header\">Returns:</p>\n\n <span style=\"font-family: 'Source Code Pro';margin-left: 2%;\">[DataModel](DataModel):&nbsp;</span>New DataModel instance with the result of the operation."
